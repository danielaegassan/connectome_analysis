
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../randomization/">
      
      
        <link rel="next" href="../network_classic/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.14">
    
    
      
        <title>Topology - connalysis</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.10ba22f1.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#these-functions-describe-topologically-motivated-network-metrics" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="connalysis" class="md-header__button md-logo" aria-label="connalysis" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            connalysis
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Topology
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/danielaegassan/connectome_analysis" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="connalysis" class="md-nav__button md-logo" aria-label="connalysis" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    connalysis
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/danielaegassan/connectome_analysis" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Introduction
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Modules
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Modules
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../modelling/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Modelling
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../randomization/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Randomization
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" checked>
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Network
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            Network
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Topology
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Topology
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#these-functions-describe-topologically-motivated-network-metrics" class="md-nav__link">
    <span class="md-ellipsis">
      These functions describe topologically motivated network metrics.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology" class="md-nav__link">
    <span class="md-ellipsis">
      topology
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.bedge_counts" class="md-nav__link">
    <span class="md-ellipsis">
      bedge_counts
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.betti_counts" class="md-nav__link">
    <span class="md-ellipsis">
      betti_counts
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.count_rc_edges_skeleta" class="md-nav__link">
    <span class="md-ellipsis">
      count_rc_edges_skeleta
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.count_triads_fully_connected" class="md-nav__link">
    <span class="md-ellipsis">
      count_triads_fully_connected
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.cross_col_k_in_degree" class="md-nav__link">
    <span class="md-ellipsis">
      cross_col_k_in_degree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.dc" class="md-nav__link">
    <span class="md-ellipsis">
      dc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.edge_participation" class="md-nav__link">
    <span class="md-ellipsis">
      edge_participation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.euler_characteristic" class="md-nav__link">
    <span class="md-ellipsis">
      euler_characteristic
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.extract_submatrices_from_edge_participation" class="md-nav__link">
    <span class="md-ellipsis">
      extract_submatrices_from_edge_participation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.extract_submatrix_from_simplex_list" class="md-nav__link">
    <span class="md-ellipsis">
      extract_submatrix_from_simplex_list
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.get_all_simplices_from_max" class="md-nav__link">
    <span class="md-ellipsis">
      get_all_simplices_from_max
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.get_k_skeleta_graph" class="md-nav__link">
    <span class="md-ellipsis">
      get_k_skeleta_graph
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.in_degree_from_pop" class="md-nav__link">
    <span class="md-ellipsis">
      in_degree_from_pop
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.list_simplices_by_dimension" class="md-nav__link">
    <span class="md-ellipsis">
      list_simplices_by_dimension
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.nbc" class="md-nav__link">
    <span class="md-ellipsis">
      nbc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.node_degree" class="md-nav__link">
    <span class="md-ellipsis">
      node_degree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.node_k_degree" class="md-nav__link">
    <span class="md-ellipsis">
      node_k_degree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.node_participation" class="md-nav__link">
    <span class="md-ellipsis">
      node_participation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.normalised_simplex_count" class="md-nav__link">
    <span class="md-ellipsis">
      normalised_simplex_count
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.normalized_simplex_counts" class="md-nav__link">
    <span class="md-ellipsis">
      normalized_simplex_counts
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.rc_submatrix" class="md-nav__link">
    <span class="md-ellipsis">
      rc_submatrix
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.simplex_counts" class="md-nav__link">
    <span class="md-ellipsis">
      simplex_counts
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.simplicial_rich_club_curve" class="md-nav__link">
    <span class="md-ellipsis">
      simplicial_rich_club_curve
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.tcc" class="md-nav__link">
    <span class="md-ellipsis">
      tcc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.underlying_undirected_matrix" class="md-nav__link">
    <span class="md-ellipsis">
      underlying_undirected_matrix
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../network_classic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Classic
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../network_local/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Local
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../network_stats/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Stats
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../about.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    About
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#these-functions-describe-topologically-motivated-network-metrics" class="md-nav__link">
    <span class="md-ellipsis">
      These functions describe topologically motivated network metrics.
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology" class="md-nav__link">
    <span class="md-ellipsis">
      topology
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.bedge_counts" class="md-nav__link">
    <span class="md-ellipsis">
      bedge_counts
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.betti_counts" class="md-nav__link">
    <span class="md-ellipsis">
      betti_counts
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.count_rc_edges_skeleta" class="md-nav__link">
    <span class="md-ellipsis">
      count_rc_edges_skeleta
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.count_triads_fully_connected" class="md-nav__link">
    <span class="md-ellipsis">
      count_triads_fully_connected
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.cross_col_k_in_degree" class="md-nav__link">
    <span class="md-ellipsis">
      cross_col_k_in_degree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.dc" class="md-nav__link">
    <span class="md-ellipsis">
      dc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.edge_participation" class="md-nav__link">
    <span class="md-ellipsis">
      edge_participation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.euler_characteristic" class="md-nav__link">
    <span class="md-ellipsis">
      euler_characteristic
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.extract_submatrices_from_edge_participation" class="md-nav__link">
    <span class="md-ellipsis">
      extract_submatrices_from_edge_participation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.extract_submatrix_from_simplex_list" class="md-nav__link">
    <span class="md-ellipsis">
      extract_submatrix_from_simplex_list
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.get_all_simplices_from_max" class="md-nav__link">
    <span class="md-ellipsis">
      get_all_simplices_from_max
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.get_k_skeleta_graph" class="md-nav__link">
    <span class="md-ellipsis">
      get_k_skeleta_graph
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.in_degree_from_pop" class="md-nav__link">
    <span class="md-ellipsis">
      in_degree_from_pop
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.list_simplices_by_dimension" class="md-nav__link">
    <span class="md-ellipsis">
      list_simplices_by_dimension
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.nbc" class="md-nav__link">
    <span class="md-ellipsis">
      nbc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.node_degree" class="md-nav__link">
    <span class="md-ellipsis">
      node_degree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.node_k_degree" class="md-nav__link">
    <span class="md-ellipsis">
      node_k_degree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.node_participation" class="md-nav__link">
    <span class="md-ellipsis">
      node_participation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.normalised_simplex_count" class="md-nav__link">
    <span class="md-ellipsis">
      normalised_simplex_count
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.normalized_simplex_counts" class="md-nav__link">
    <span class="md-ellipsis">
      normalized_simplex_counts
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.rc_submatrix" class="md-nav__link">
    <span class="md-ellipsis">
      rc_submatrix
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.simplex_counts" class="md-nav__link">
    <span class="md-ellipsis">
      simplex_counts
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.simplicial_rich_club_curve" class="md-nav__link">
    <span class="md-ellipsis">
      simplicial_rich_club_curve
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.tcc" class="md-nav__link">
    <span class="md-ellipsis">
      tcc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#src.connalysis.network.topology.underlying_undirected_matrix" class="md-nav__link">
    <span class="md-ellipsis">
      underlying_undirected_matrix
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>Topology</h1>

<h2 id="these-functions-describe-topologically-motivated-network-metrics">These functions describe topologically motivated network metrics.</h2>


<div class="doc doc-object doc-module">



<a id="src.connalysis.network.topology"></a>
  <div class="doc doc-contents first">

  

  <div class="doc doc-children">










<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.bedge_counts" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">bedge_counts</span><span class="p">(</span><span class="n">adjacency</span><span class="p">,</span> <span class="n">simplices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Counts the total number of edges in each position on the subgraphs defined by the nodes
of the simplices listed in simplices.  If a simplex list is not passed, simplices are computed on
the adjacency matrix.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adjacency</code></td>
          <td>
                <code>(N,N)-array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.
The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>simplices</code></td>
          <td>
                <code>series</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Series  of 2d-arrays indexed by dimension.
Each array is of dimension (no. of simplices, dimension).
Each row corresponds to a list of nodes on a simplex.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If False counts all simplices in adj.
If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension up to which simplex motifs are counted.
The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</p>
            </div>
          </td>
          <td>
                <code>-1</code>
          </td>
        </tr>
        <tr>
          <td><code>simplex_type</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>See <a href="./#src.connalysis.network.topology.simplex_counts">simplex_counts</a></p>
            </div>
          </td>
          <td>
                <code>&#39;directed&#39;</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>series</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>pandas series with index dimensions values (dim+1, dim+1) arrays.  The (i,j) entry counts the number of edges
from node i to node j on all the subgraphs of adjacency on the nodes of the simplices listed.  See notes.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

<details class="note" open>
  <summary>Notes</summary>
  <p>Every directed <span class="arithmatex">\(k\)</span>-simplex <span class="arithmatex">\([v_o, v_1, \ldots, v_k]\)</span> defines as subgraph of the adjacency matrix, with edges
<span class="arithmatex">\(v_i \to v_j\)</span> whenever <span class="arithmatex">\(i\leq j\)</span>, but also possibly with ''reverse'' edges.  One can represent this structure
with a non-symmetric <span class="arithmatex">\((k+1, k+1)\)</span>-matrix with <code>1</code>'s for every edge in the subgraph.  The output of this function
gives for each dimension the sum of all these matrices over all the simplices provided in <code>simplices</code> or over
all the simplices in the adjacency matrix if none is provided.  The lower triangular part of these matrices is
therefore a metric of recurrence within simplices, or "higher dimensional recurrence".
In particular, in dimension 1 it is the number of reciprocal edges in the network.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">bedge_counts</span><span class="p">(</span><span class="n">adjacency</span><span class="p">,</span> <span class="n">simplices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_simplices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">simplex_type</span> <span class="o">=</span> <span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="o">**</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Counts the total number of edges in each position on the subgraphs defined by the nodes</span>
<span class="sd">    of the simplices listed in simplices.  If a simplex list is not passed, simplices are computed on</span>
<span class="sd">    the adjacency matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adjacency : (N,N)-array or sparse matrix</span>
<span class="sd">        Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.</span>
<span class="sd">        The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    simplices : series</span>
<span class="sd">        Series  of 2d-arrays indexed by dimension.</span>
<span class="sd">        Each array is of dimension (no. of simplices, dimension).</span>
<span class="sd">        Each row corresponds to a list of nodes on a simplex.</span>
<span class="sd">    max_simplices : bool</span>
<span class="sd">        If False counts all simplices in adj.</span>
<span class="sd">        If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension up to which simplex motifs are counted.</span>
<span class="sd">        The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</span>
<span class="sd">    simplex_type: str</span>
<span class="sd">        See [simplex_counts](network_topology.md#src.connalysis.network.topology.simplex_counts)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    series</span>
<span class="sd">        pandas series with index dimensions values (dim+1, dim+1) arrays.  The (i,j) entry counts the number of edges</span>
<span class="sd">        from node i to node j on all the subgraphs of adjacency on the nodes of the simplices listed.  See notes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -------</span>
<span class="sd">    Every directed $k$-simplex $[v_o, v_1, \\ldots, v_k]$ defines as subgraph of the adjacency matrix, with edges</span>
<span class="sd">    $v_i \\to v_j$ whenever $i\leq j$, but also possibly with &#39;&#39;reverse&#39;&#39; edges.  One can represent this structure</span>
<span class="sd">    with a non-symmetric $(k+1, k+1)$-matrix with `1`&#39;s for every edge in the subgraph.  The output of this function</span>
<span class="sd">    gives for each dimension the sum of all these matrices over all the simplices provided in `simplices` or over</span>
<span class="sd">    all the simplices in the adjacency matrix if none is provided.  The lower triangular part of these matrices is</span>
<span class="sd">    therefore a metric of recurrence within simplices, or &quot;higher dimensional recurrence&quot;.</span>
<span class="sd">    In particular, in dimension 1 it is the number of reciprocal edges in the network.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adj</span> <span class="o">=</span> <span class="n">adjacency</span>

    <span class="k">if</span> <span class="n">simplices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;COMPUTE `bedge_counts(...)`: No argued simplices.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bedge_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span>
                            <span class="n">list_simplices_by_dimension</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">max_simplices</span> <span class="o">=</span> <span class="n">max_simplices</span><span class="p">,</span>
                                                        <span class="n">max_dim</span> <span class="o">=</span> <span class="n">max_dim</span><span class="p">,</span> <span class="n">simplex_type</span> <span class="o">=</span> <span class="n">simplex_type</span><span class="p">,</span> <span class="o">**</span> <span class="n">kwargs</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;COMPUTE `bedge_counts(...): for simplices: </span><span class="si">%s</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="n">simplices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">dense</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">adjacency</span><span class="o">.</span><span class="n">toarray</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subset_adj</span><span class="p">(</span><span class="n">simplex</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dense</span><span class="p">[</span><span class="n">simplex</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">simplex</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">count_bedges</span><span class="p">(</span><span class="n">simplices_given_dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;...&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d_simplices</span> <span class="o">=</span> <span class="n">simplices_given_dim</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">d_simplices</span> <span class="o">=</span> <span class="n">simplices_given_dim</span>

        <span class="k">if</span> <span class="n">d_simplices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">d_simplices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d_simplices</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">d_simplices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">subset_adj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">simplices</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">count_bedges</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.betti_counts" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">betti_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="p">[],</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="n">approximation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Count betti counts of flag complex of adj.  Type of flag complex is given by simplex_type.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d (N,N)-array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.
The matrix can be asymmetric, but must have 0 in the diagonal.  Matrix will be cast to 0,1 entries so weights
will be ignored.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>node_properties</code></td>
          <td>
                <code> data frame</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>min_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Minimal dimension from which betti counts are computed.
The default min_dim = 0 (counting number of connected components).</p>
            </div>
          </td>
          <td>
                <code>0</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension up to which simplex motifs are counted.
The default max_dim = [] counts betti numbers up to the maximal dimension of the complex.</p>
            </div>
          </td>
          <td>
                <code>[]</code>
          </td>
        </tr>
        <tr>
          <td><code>simplex_type</code></td>
          <td>
                <code>string</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Type of flag complex to consider, given by the type of simplices it is built on.
Possible types are:</p>
<p>’directed’ - directed simplices (directed flag complex)</p>
<p>’undirected’ - simplices in the underlying undirected graph (clique complex of the underlying undirected graph)</p>
<p>’reciprocal’ - simplices in the undirected graph of reciprocal connections (clique complex of the
undirected graph of reciprocal connections.)</p>
            </div>
          </td>
          <td>
                <code>&#39;directed&#39;</code>
          </td>
        </tr>
        <tr>
          <td><code>approximation</code></td>
          <td>
                <code>list of integers  or None</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Approximation parameter for the computation of the betti numbers.  Useful for large networks.
If None all betti numbers are computed exactly.
Otherwise, min_dim must be 0 and approximation but be a list of positive integers or -1.
The list approximation is either extended by -1 entries on the right or sliced from [0:max_dim+1] to obtain
a list of length max_dim.  Each entry of the list denotes the approximation value for the betti computation
of that dimension if -1 approximation in that dimension is set to None.</p>
<p>If the approximation value at a given dimension is <code>a</code> flagser skips cells creating columns in the reduction
matrix with more than <code>a</code> entries.  This is useful for hard problems.  For large, sparse networks a good value
if often <code>100,00</code>.  If set to <code>1</code> that dimension will be virtually ignored.  See [1]_</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>series</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Betti counts indexed per dimension from min_dim to max_dim.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj has non-zero entries in the diagonal which can produce errors.</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj is not square.</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If approximation != None and min_dim != 0.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

<details class="see-also" open>
  <summary>See Also</summary>
  <p><a href="./#src.connalysis.network.topology.simplex_counts">simplex_counts</a> :
A function that counts the simplices forming the complex from which bettis are count.
Simplex types are described there in detail.</p>
</details>
<details class="references" open>
  <summary>References</summary>
  <p>For details about the approximation algorithm see</p>
<p>..[1] D. Luetgehetmann, "Documentation of the C++ flagser library";
       <a href="https://github.com/luetge/flagser/blob/master/docs/documentation_flagser.pdf">GitHub: luetge/flagser</a>.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">betti_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">min_dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="p">[],</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="n">approximation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Count betti counts of flag complex of adj.  Type of flag complex is given by simplex_type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d (N,N)-array or sparse matrix</span>
<span class="sd">        Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.</span>
<span class="sd">        The matrix can be asymmetric, but must have 0 in the diagonal.  Matrix will be cast to 0,1 entries so weights</span>
<span class="sd">        will be ignored.</span>
<span class="sd">    node_properties :  data frame</span>
<span class="sd">        Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</span>
<span class="sd">    min_dim : int</span>
<span class="sd">        Minimal dimension from which betti counts are computed.</span>
<span class="sd">        The default min_dim = 0 (counting number of connected components).</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension up to which simplex motifs are counted.</span>
<span class="sd">        The default max_dim = [] counts betti numbers up to the maximal dimension of the complex.</span>
<span class="sd">    simplex_type : string</span>
<span class="sd">        Type of flag complex to consider, given by the type of simplices it is built on.</span>
<span class="sd">        Possible types are:</span>

<span class="sd">        ’directed’ - directed simplices (directed flag complex)</span>

<span class="sd">        ’undirected’ - simplices in the underlying undirected graph (clique complex of the underlying undirected graph)</span>

<span class="sd">        ’reciprocal’ - simplices in the undirected graph of reciprocal connections (clique complex of the</span>
<span class="sd">        undirected graph of reciprocal connections.)</span>
<span class="sd">    approximation : list of integers  or None</span>
<span class="sd">        Approximation parameter for the computation of the betti numbers.  Useful for large networks.</span>
<span class="sd">        If None all betti numbers are computed exactly.</span>
<span class="sd">        Otherwise, min_dim must be 0 and approximation but be a list of positive integers or -1.</span>
<span class="sd">        The list approximation is either extended by -1 entries on the right or sliced from [0:max_dim+1] to obtain</span>
<span class="sd">        a list of length max_dim.  Each entry of the list denotes the approximation value for the betti computation</span>
<span class="sd">        of that dimension if -1 approximation in that dimension is set to None.</span>

<span class="sd">        If the approximation value at a given dimension is `a` flagser skips cells creating columns in the reduction</span>
<span class="sd">        matrix with more than `a` entries.  This is useful for hard problems.  For large, sparse networks a good value</span>
<span class="sd">        if often `100,00`.  If set to `1` that dimension will be virtually ignored.  See [1]_</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    series</span>
<span class="sd">        Betti counts indexed per dimension from min_dim to max_dim.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj has non-zero entries in the diagonal which can produce errors.</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj is not square.</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If approximation != None and min_dim != 0.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    [simplex_counts](network_topology.md#src.connalysis.network.topology.simplex_counts) :</span>
<span class="sd">    A function that counts the simplices forming the complex from which bettis are count.</span>
<span class="sd">    Simplex types are described there in detail.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    For details about the approximation algorithm see</span>

<span class="sd">    ..[1] D. Luetgehetmann, &quot;Documentation of the C++ flagser library&quot;;</span>
<span class="sd">           [GitHub: luetge/flagser](https://github.com/luetge/flagser/blob/master/docs/documentation_flagser.pdf).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Compute betti counts for </span><span class="si">%s</span><span class="s2">-type adjacency matrix and </span><span class="si">%s</span><span class="s2">-type node properties&quot;</span><span class="p">,</span>
             <span class="nb">type</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">node_properties</span><span class="p">))</span>

    <span class="kn">from</span> <span class="nn">pyflagser</span> <span class="kn">import</span> <span class="n">flagser_unweighted</span>

    <span class="c1">#Checking matrix</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;The diagonal of the matrix is non-zero and this may lead to errors!&#39;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">N</span> <span class="o">==</span> <span class="n">M</span><span class="p">,</span> <span class="s1">&#39;Dimension mismatch. The matrix must be square.&#39;</span>
    <span class="k">assert</span> <span class="ow">not</span><span class="p">((</span><span class="ow">not</span> <span class="n">approximation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">min_dim</span><span class="o">!=</span><span class="mi">0</span><span class="p">)),</span> \
        <span class="s1">&#39;For approximation != None, min_dim must be set to 0.  </span><span class="se">\n</span><span class="s1">Lower dimensions can be ignored by setting approximation to 1 on those dimensions&#39;</span>

    <span class="c1"># Symmetrize matrix if simplex_type is not &#39;directed&#39;</span>
    <span class="k">if</span> <span class="n">simplex_type</span> <span class="o">==</span> <span class="s1">&#39;undirected&#39;</span><span class="p">:</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">underlying_undirected_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span>  <span class="c1"># symmtrize and keep upper triangular only</span>
    <span class="k">elif</span> <span class="n">simplex_type</span> <span class="o">==</span> <span class="s2">&quot;reciprocal&quot;</span><span class="p">:</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">rc_submatrix</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span>  <span class="c1"># symmtrize and keep upper triangular only</span>
    <span class="c1">#Computing bettis</span>
    <span class="k">if</span> <span class="n">max_dim</span><span class="o">==</span><span class="p">[]:</span>
        <span class="n">max_dim</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">if</span> <span class="n">approximation</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Run without approximation&quot;</span><span class="p">)</span>
        <span class="n">bettis</span> <span class="o">=</span> <span class="n">flagser_unweighted</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">min_dimension</span><span class="o">=</span><span class="n">min_dim</span><span class="p">,</span> <span class="n">max_dimension</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span>
                                    <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="n">approximation</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="s1">&#39;betti&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">approximation</span><span class="p">]))</span> <span class="c1"># assert it&#39;s a list of integers</span>
        <span class="n">approximation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">approximation</span><span class="p">)</span>
        <span class="n">bettis</span><span class="o">=</span><span class="p">[]</span>

        <span class="c1">#Make approximation vector to be of size max_dim</span>
        <span class="k">if</span> <span class="n">max_dim</span><span class="o">!=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">approximation</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">max_dim</span><span class="p">:</span><span class="c1">#Vector too short so pad with -1&#39;s</span>
                <span class="n">approximation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">approximation</span><span class="p">,</span>
                                     <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_dim</span><span class="o">-</span><span class="p">(</span><span class="n">approximation</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
                                     <span class="s1">&#39;constant&#39;</span><span class="p">,</span><span class="n">constant_values</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">approximation</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="n">max_dim</span><span class="p">:</span><span class="c1">#Vector too long, select relevant slice</span>
                <span class="n">approximation</span><span class="o">=</span><span class="n">approximation</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">max_dim</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#Sanity check</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Correct dimensions for approximation: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">approximation</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="n">max_dim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">#Split approximation into sub-vectors of same value to speed up computation</span>
        <span class="n">diff</span><span class="o">=</span><span class="n">approximation</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">approximation</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">slice_indx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span><span class="o">!=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span>

        <span class="c1">#Compute betti counts</span>
        <span class="k">for</span> <span class="n">dims_range</span> <span class="ow">in</span>  <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">approximation</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">slice_indx</span><span class="p">):</span>
            <span class="n">n</span><span class="o">=</span><span class="n">dims_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#min dim for computation</span>
            <span class="n">N</span><span class="o">=</span><span class="n">dims_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#max dim for computation</span>
            <span class="n">a</span><span class="o">=</span><span class="n">approximation</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">a</span><span class="o">=</span><span class="kc">None</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Run betti for dim range </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2"> with approximation </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
            <span class="n">bettis</span><span class="o">=</span><span class="n">bettis</span><span class="o">+</span><span class="n">flagser_unweighted</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">min_dimension</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">max_dimension</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
                                             <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                             <span class="n">approximation</span><span class="o">=</span><span class="n">a</span><span class="p">)[</span><span class="s1">&#39;betti&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">max_dim</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">n</span><span class="o">=</span><span class="n">approximation</span><span class="o">.</span><span class="n">size</span> <span class="c1">#min dim for computation</span>
            <span class="n">N</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="c1">#max dim for computation</span>
            <span class="n">a</span><span class="o">=</span><span class="kc">None</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Run betti for dim range </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2"> with approximation </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
            <span class="n">bettis</span><span class="o">=</span><span class="n">bettis</span><span class="o">+</span><span class="n">flagser_unweighted</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">min_dimension</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">max_dimension</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
                                             <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                             <span class="n">approximation</span><span class="o">=</span><span class="n">a</span><span class="p">)[</span><span class="s1">&#39;betti&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">bettis</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;betti_count&quot;</span><span class="p">,</span>
                     <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bettis</span><span class="p">)</span><span class="o">+</span><span class="n">min_dim</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dim&quot;</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.count_rc_edges_skeleta" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">count_rc_edges_skeleta</span><span class="p">(</span><span class="n">adj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">simplex_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">return_mats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Count the edges and reciprocal edges in the k-<code>skeleta</code> of the directed flag complex of adj for all
k&lt;= max_dim. If simplex list are provided, it will compute the skeleta directly from these and not use adj.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>(N,N)-array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.
The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If False counts all simplices in adj.
If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension up to which simplex motifs are counted.
The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</p>
            </div>
          </td>
          <td>
                <code>-1</code>
          </td>
        </tr>
        <tr>
          <td><code>simplex</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Series 2d-arrays indexed by dimension.
Each array is of dimension (no. of simplices, dimension).
Each row corresponds to a list of nodes on a simplex.
If provided adj will be ignored but N will be required.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>edge_par</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>DataFrame with edge participation values formatted as the output of <code>edge_participation</code> i.e.,
indexed by the edges in adj and with columns de dimension for which edge participation is counted</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>N</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Number of nodes in original graph.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>simple_type</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>See <a href="./#src.connalysis.network.topology.simplex_counts">simplex_counts</a></p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>position</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Position of the edges to extract</p>
<p>'all': all edges of the simplex</p>
<p>'spine': edges along the spine of the simplex
(only makes sense if simplices are directed)</p>
            </div>
          </td>
          <td>
                <code>&#39;all&#39;</code>
          </td>
        </tr>
        <tr>
          <td><code>return_mats</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If True return the matrices of the underlying graphs of the k-skeleta as in
get_k_skeleta_graph</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>threads</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Number of threads into which to parallelize the computation</p>
            </div>
          </td>
          <td>
                <code>8</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>data frame, (dict)</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>data frame with index dimensions and columns number of (rc) edges in the corresponding skeleta
if return_mats==True, also return the graphs of the k-skeleta as in get_k_skeleta_graph.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If neither adj nor precomputed simplex_list or edge_par values are provided</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If N &lt;= than an entry in the simplex list</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

<details class="see-also" open>
  <summary>See Also</summary>
  <p><a href="./#src.connalysis.network.topology.edge_participation">edge_participation</a> :
A function that counts the number of times an edge is part of a simplex.</p>
<p><a href="./#src.connalysis.network.topology.simplex_counts">simplex_counts</a> :
A function that counts the simplices forming the complex from which bettis are count,
where simplex types are described in detail.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">count_rc_edges_skeleta</span><span class="p">(</span><span class="n">adj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">simplex_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                           <span class="n">return_mats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Count the edges and reciprocal edges in the k-``skeleta`` of the directed flag complex of adj for all</span>
<span class="sd">    k&lt;= max_dim. If simplex list are provided, it will compute the skeleta directly from these and not use adj.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : (N,N)-array or sparse matrix</span>
<span class="sd">        Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.</span>
<span class="sd">        The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    max_simplices : bool</span>
<span class="sd">        If False counts all simplices in adj.</span>
<span class="sd">        If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension up to which simplex motifs are counted.</span>
<span class="sd">        The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</span>
<span class="sd">    simplex list: series</span>
<span class="sd">        Series 2d-arrays indexed by dimension.</span>
<span class="sd">        Each array is of dimension (no. of simplices, dimension).</span>
<span class="sd">        Each row corresponds to a list of nodes on a simplex.</span>
<span class="sd">        If provided adj will be ignored but N will be required.</span>
<span class="sd">    edge_par: DataFrame</span>
<span class="sd">        DataFrame with edge participation values formatted as the output of ``edge_participation`` i.e.,</span>
<span class="sd">        indexed by the edges in adj and with columns de dimension for which edge participation is counted</span>
<span class="sd">    N: int</span>
<span class="sd">        Number of nodes in original graph.</span>
<span class="sd">    simple_type: str</span>
<span class="sd">        See [simplex_counts](network_topology.md#src.connalysis.network.topology.simplex_counts)</span>
<span class="sd">    position: str</span>
<span class="sd">        Position of the edges to extract</span>

<span class="sd">        &#39;all&#39;: all edges of the simplex</span>

<span class="sd">        &#39;spine&#39;: edges along the spine of the simplex</span>
<span class="sd">        (only makes sense if simplices are directed)</span>
<span class="sd">    return_mats : bool</span>
<span class="sd">        If True return the matrices of the underlying graphs of the k-skeleta as in</span>
<span class="sd">        get_k_skeleta_graph</span>
<span class="sd">    threads: int</span>
<span class="sd">        Number of threads into which to parallelize the computation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data frame, (dict)</span>
<span class="sd">        data frame with index dimensions and columns number of (rc) edges in the corresponding skeleta</span>
<span class="sd">        if return_mats==True, also return the graphs of the k-skeleta as in get_k_skeleta_graph.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If neither adj nor precomputed simplex_list or edge_par values are provided</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If N &lt;= than an entry in the simplex list</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    [edge_participation](network_topology.md#src.connalysis.network.topology.edge_participation) :</span>
<span class="sd">    A function that counts the number of times an edge is part of a simplex.</span>

<span class="sd">    [simplex_counts](network_topology.md#src.connalysis.network.topology.simplex_counts) :</span>
<span class="sd">    A function that counts the simplices forming the complex from which bettis are count,</span>
<span class="sd">    where simplex types are described in detail.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if enough inputs are provided</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">position</span> <span class="o">==</span> <span class="s1">&#39;spine&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">simplex_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">not_precomputed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">position</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edge_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">not_precomputed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">not_precomputed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">adj</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">not_precomputed</span><span class="p">),</span> <span class="s2">&quot;Either adj or simplex_list/edge_participation need to be provided&quot;</span>

    <span class="k">if</span> <span class="n">not_precomputed</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;spine&quot;</span><span class="p">:</span>  <span class="c1"># Compute simplex since they are not provided</span>
            <span class="n">simplex_list</span> <span class="o">=</span> <span class="n">list_simplices_by_dimension</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                       <span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span>
                                                       <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span>
                                                       <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>  <span class="c1"># More efficient than going from simplex lists if the position is not important</span>
            <span class="n">edge_par</span><span class="p">,</span> <span class="n">simplex_counts</span> <span class="o">=</span> <span class="n">edge_participation</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span>
                                                          <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="n">simplex_type</span><span class="p">,</span>
                                                          <span class="n">return_simplex_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;spine&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">simplex_list</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span><span class="o">.</span><span class="n">explode</span><span class="p">()),</span> \
                <span class="s2">&quot;N must be larger than all the entries in the simplex list&quot;</span>

    <span class="c1"># Extract &#39;k&#39;-skeleton and count (rc-)edges</span>
    <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;spine&quot;</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">simplex_list</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">simplex_list</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Doesn&#39;t make sense to look at the 0-skeleton</span>
    <span class="k">elif</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">edge_par</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dim&quot;</span><span class="p">)</span>
    <span class="n">edge_counts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;number_of_edges&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_rc_edges&quot;</span><span class="p">,</span> <span class="s2">&quot;rc/edges_percent&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">return_mats</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">skeleton_mats</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;dimension_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;spine&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simplex_list</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">simplex_list</span><span class="p">[</span><span class="n">dim</span><span class="p">]),</span> \
                    <span class="s2">&quot;N must be larger than all the entries in the simplex list&quot;</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">extract_submatrix_from_simplex_list</span><span class="p">(</span><span class="n">simplex_list</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">N</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">sum</span><span class="p">();</span>
                <span class="n">rc_edges</span> <span class="o">=</span> <span class="n">rc_submatrix</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">edge_counts</span><span class="p">[</span><span class="s2">&quot;number_of_edges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span>
                <span class="n">edge_counts</span><span class="p">[</span><span class="s2">&quot;number_of_rc_edges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">rc_edges</span>
                <span class="n">edge_counts</span><span class="p">[</span><span class="s2">&quot;rc/edges_percent&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rc_edges</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="n">edges</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edge_counts</span><span class="p">[</span><span class="s2">&quot;number_of_edges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">return_mats</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">skeleton_mats</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;dimension_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span>
    <span class="k">elif</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">skeleton_mats</span> <span class="o">=</span> <span class="n">extract_submatrices_from_edge_participation</span><span class="p">(</span><span class="n">edge_par</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">skeleton_mats</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;dimension_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">edge_counts</span><span class="p">[</span><span class="s2">&quot;number_of_edges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span>
            <span class="k">if</span> <span class="n">edges</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rc_edges</span> <span class="o">=</span> <span class="n">rc_submatrix</span><span class="p">(</span><span class="n">skeleton_mats</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;dimension_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">edge_counts</span><span class="p">[</span><span class="s2">&quot;number_of_rc_edges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">rc_edges</span>
                <span class="n">edge_counts</span><span class="p">[</span><span class="s2">&quot;rc/edges_percent&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rc_edges</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="n">edges</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edge_counts</span><span class="p">[</span><span class="s2">&quot;number_of_rc_edges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">edge_counts</span><span class="p">[</span><span class="s2">&quot;rc/edges_percent&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">return_mats</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">edge_counts</span><span class="p">,</span> <span class="n">skeleton_mats</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">edge_counts</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.count_triads_fully_connected" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">count_triads_fully_connected</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">max_num_sampled</span><span class="o">=</span><span class="mi">5000000</span><span class="p">,</span> <span class="n">return_normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Counts the numbers of each triadic motif in the matrix adj.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d-array</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>max_num_sampled</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The maximal number of connected triads classified. If the number of
connected triads is higher than that, only the specified number is sampled at random and
classified. The final counts are extrapolated as (actual_num_triads/ max_num_sampled) * counts.</p>
            </div>
          </td>
          <td>
                <code>5000000</code>
          </td>
        </tr>
        <tr>
          <td><code>return_normalized</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If True return the triad counts divided by the size of each isomorphism class.  That is, the total counts
divided by the following array:</p>
<p><span class="arithmatex">\([6, 3, 3, 6, 6, 6, 2, 3, 6, 3, 3, 6, 1].\)</span></p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>1d-array</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The counts of the various triadic motifs in adj as ordered in Figure 5 [1]_.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

<details class="note" open>
  <summary>Notes</summary>
  <p>Only connectected motifs are counted, i.e. motifs with less than 2 connections or only a single bidirectional
connection are not counted. The connected motifs are ordered as in Figure 5 [1]_.</p>
</details>
<details class="references" open>
  <summary>References</summary>
  <p>..[1] Gal, Eyal, et al.
<a href="https://www.nature.com/articles/nn.4576">"Rich cell-type-specific network topology in neocortical microcircuitry."</a>
Nature neuroscience 20.7 (2017): 1004-1013.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span>
<span class="normal">1427</span>
<span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span>
<span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span>
<span class="normal">1494</span>
<span class="normal">1495</span>
<span class="normal">1496</span>
<span class="normal">1497</span>
<span class="normal">1498</span>
<span class="normal">1499</span>
<span class="normal">1500</span>
<span class="normal">1501</span>
<span class="normal">1502</span>
<span class="normal">1503</span>
<span class="normal">1504</span>
<span class="normal">1505</span>
<span class="normal">1506</span>
<span class="normal">1507</span>
<span class="normal">1508</span>
<span class="normal">1509</span>
<span class="normal">1510</span>
<span class="normal">1511</span>
<span class="normal">1512</span>
<span class="normal">1513</span>
<span class="normal">1514</span>
<span class="normal">1515</span>
<span class="normal">1516</span>
<span class="normal">1517</span>
<span class="normal">1518</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">count_triads_fully_connected</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">max_num_sampled</span><span class="o">=</span><span class="mi">5000000</span><span class="p">,</span> <span class="n">return_normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Counts the numbers of each triadic motif in the matrix adj.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d-array</span>
<span class="sd">        Adjacency matrix of a directed network.</span>
<span class="sd">    max_num_sampled : int</span>
<span class="sd">        The maximal number of connected triads classified. If the number of</span>
<span class="sd">        connected triads is higher than that, only the specified number is sampled at random and</span>
<span class="sd">        classified. The final counts are extrapolated as (actual_num_triads/ max_num_sampled) * counts.</span>
<span class="sd">    return_normalized : bool</span>
<span class="sd">        If True return the triad counts divided by the size of each isomorphism class.  That is, the total counts</span>
<span class="sd">        divided by the following array:</span>

<span class="sd">        $[6, 3, 3, 6, 6, 6, 2, 3, 6, 3, 3, 6, 1].$</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    1d-array</span>
<span class="sd">        The counts of the various triadic motifs in adj as ordered in Figure 5 [1]_.</span>

<span class="sd">    Notes</span>
<span class="sd">    ------</span>
<span class="sd">    Only connectected motifs are counted, i.e. motifs with less than 2 connections or only a single bidirectional</span>
<span class="sd">    connection are not counted. The connected motifs are ordered as in Figure 5 [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    -------</span>

<span class="sd">    ..[1] Gal, Eyal, et al.</span>
<span class="sd">    [&quot;Rich cell-type-specific network topology in neocortical microcircuitry.&quot;](https://www.nature.com/articles/nn.4576)</span>
<span class="sd">    Nature neuroscience 20.7 (2017): 1004-1013.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Functions to indetify triads</span>
    <span class="k">def</span> <span class="nf">canonical_sort</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sorts row/columns of the matrix adj using the lexicographical order of the</span>
<span class="sd">        tuple (out_degree, in_degree).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        M : 2d-array</span>
<span class="sd">            Adjacency matrix of a directed network.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2d-array</span>
<span class="sd">            the matrix adj with rows/columns sorted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">in_degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">out_degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">in_degree</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">out_degree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">identify_motif</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identifies the connected directed digraph on three nodes M as on in the full classification</span>
<span class="sd">        list given in the dictionary triad_dict.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        M : array</span>
<span class="sd">            A (3,3) array describing a directed connected digraph on three nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The index of the motif as indexed in the dictiroanry triad_dict which follows the</span>
<span class="sd">        ordering of Gal et al., 2017</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">triad_code</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">canonical_sort</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">triad_dict</span><span class="p">[</span><span class="n">triad_code</span><span class="p">]</span>

    <span class="c1"># Finding and counting triads</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>  <span class="c1"># Casting to array makes finding triads an order of magnitude faster</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">undirected_adj</span> <span class="o">=</span> <span class="n">underlying_undirected_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="c1"># Matrix with i,j entries number of undirected paths between i and j in adj</span>
    <span class="n">path_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">undirected_adj</span> <span class="o">@</span> <span class="n">undirected_adj</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">connected_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">path_counts</span><span class="p">)</span>
    <span class="n">triads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Testing </span><span class="si">{0}</span><span class="s2"> potential triadic pairs&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">connected_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">connected_pairs</span><span class="p">):</span>
        <span class="c1"># zs = np.nonzero((undirected_adj.getrow(x).multiply(undirected_adj.getrow(y))).toarray()[0])[0]</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">undirected_adj</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">undirected_adj</span><span class="p">[</span><span class="n">y</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zs</span><span class="p">:</span>
            <span class="n">triads</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])))</span>
    <span class="n">triads</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">triads</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time spent finding triads: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{0}</span><span class="s2"> connected triads&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">triads</span><span class="p">)))</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">triad_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">sample_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">triads</span><span class="p">),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">max_num_sampled</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">triads</span><span class="p">)),</span>
                                  <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">sample_idx</span><span class="p">:</span>
        <span class="n">triad</span> <span class="o">=</span> <span class="n">triads</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">motif_id</span> <span class="o">=</span> <span class="n">identify_motif</span><span class="p">(</span><span class="n">adj</span><span class="p">[:,</span> <span class="n">triad</span><span class="p">][</span><span class="n">triad</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">counts</span><span class="p">[</span><span class="n">motif_id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time spent classifying triads: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">return_normalized</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(((</span><span class="nb">len</span><span class="p">(</span><span class="n">triads</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_idx</span><span class="p">))</span> <span class="o">*</span> <span class="n">counts</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="o">/</span> <span class="n">triad_combinations</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(((</span><span class="nb">len</span><span class="p">(</span><span class="n">triads</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_idx</span><span class="p">))</span> <span class="o">*</span> <span class="n">counts</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.cross_col_k_in_degree" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">cross_col_k_in_degree</span><span class="p">(</span><span class="n">adj_cross</span><span class="p">,</span> <span class="n">adj_source</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Compute generalized in-degree of nodes in adj_target from nodes in adj_source.
The k-in-degree of a node v is the number of k-simplices in adj_source with all its nodes mapping to v
through edges in adj_cross.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj_cross</code></td>
          <td>
                <code>(n,m) array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Matrix of connections from the nodes in adj_n to the target population.
n is the number of nodes in adj_source and m is the number of nodes in adj_target.
A non-zero entry adj_cross[i,j] implies there is an edge from i-th node of adj_source
to the j-th node of adj_target.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>adj_source</code></td>
          <td>
                <code>(n, n)-array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of the source network where n is the number of nodes in the source network.
A non-zero entry adj_source[i,j] implies there is an edge from node i to j.
The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If False counts all simplices.
If True counts only maximal simplices.</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension up to which simplex motifs are counted.
The default max_dim = -1 counts all existing dimensions.
Particularly useful for large or dense graphs.</p>
            </div>
          </td>
          <td>
                <code>-1</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>Data frame</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Table of cross-k-in-degrees indexed by the m nodes in the target population.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj_source has non-zero entries in the diagonal which can produce errors.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">cross_col_k_in_degree</span><span class="p">(</span><span class="n">adj_cross</span><span class="p">,</span> <span class="n">adj_source</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1">#TODO: DO THE OUTDEGREE VERSION</span>
    <span class="c1">#TODO: Get participation directly from flagsercount via vertices to do?</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute generalized in-degree of nodes in adj_target from nodes in adj_source.</span>
<span class="sd">    The k-in-degree of a node v is the number of k-simplices in adj_source with all its nodes mapping to v</span>
<span class="sd">    through edges in adj_cross.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj_cross : (n,m) array or sparse matrix</span>
<span class="sd">        Matrix of connections from the nodes in adj_n to the target population.</span>
<span class="sd">        n is the number of nodes in adj_source and m is the number of nodes in adj_target.</span>
<span class="sd">        A non-zero entry adj_cross[i,j] implies there is an edge from i-th node of adj_source</span>
<span class="sd">        to the j-th node of adj_target.</span>
<span class="sd">    adj_source : (n, n)-array or sparse matrix</span>
<span class="sd">        Adjacency matrix of the source network where n is the number of nodes in the source network.</span>
<span class="sd">        A non-zero entry adj_source[i,j] implies there is an edge from node i to j.</span>
<span class="sd">        The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    max_simplices : bool</span>
<span class="sd">        If False counts all simplices.</span>
<span class="sd">        If True counts only maximal simplices.</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension up to which simplex motifs are counted.</span>
<span class="sd">        The default max_dim = -1 counts all existing dimensions.</span>
<span class="sd">        Particularly useful for large or dense graphs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Data frame</span>
<span class="sd">        Table of cross-k-in-degrees indexed by the m nodes in the target population.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj_source has non-zero entries in the diagonal which can produce errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adj_source</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj_source</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">adj_cross</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj_cross</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">adj_source</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> \
    <span class="s1">&#39;The diagonal of the source matrix is non-zero and this may lead to errors!&#39;</span>
    <span class="k">assert</span> <span class="n">adj_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">adj_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> \
    <span class="s1">&#39;Dimension mismatch. The source matrix must be square.&#39;</span>
    <span class="k">assert</span> <span class="n">adj_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">adj_cross</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> \
    <span class="s1">&#39;Dimension mismatch. The source matrix and cross matrix must have the same number of rows.&#39;</span>

    <span class="n">n_source</span> <span class="o">=</span> <span class="n">adj_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#Size of the source population</span>
    <span class="n">n_target</span> <span class="o">=</span> <span class="n">adj_cross</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#Size of the target population</span>
    <span class="c1"># Building a square matrix [[adj_source, adj_cross], [0,0]]</span>
    <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">bmat</span><span class="p">([[</span><span class="n">adj_source</span><span class="p">,</span> <span class="n">adj_cross</span><span class="p">],</span>
                 <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">n_target</span><span class="p">,</span> <span class="n">n_source</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">),</span>
                  <span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">n_target</span><span class="p">,</span> <span class="n">n_target</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)]])</span>
    <span class="c1"># Transposing to restrict computation to ``source nodes&#39;&#39; in adj_target in flagsercount</span>
    <span class="n">adj</span><span class="o">=</span><span class="n">adj</span><span class="o">.</span><span class="n">T</span>
    <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_source</span><span class="p">,</span> <span class="n">n_source</span><span class="o">+</span><span class="n">n_target</span><span class="p">)</span> <span class="c1">#nodes on target population</span>
    <span class="n">slist</span><span class="o">=</span><span class="n">list_simplices_by_dimension</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
                                      <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1">#Count participation as a source in transposed matrix i.e. participation as sink in the original</span>
    <span class="n">cross_col_deg</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">slist</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">index</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">slist</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">index</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">slist</span><span class="p">[</span><span class="n">dim</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cross_col_deg</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">=</span><span class="n">deg</span>
    <span class="n">cross_col_deg</span><span class="o">=</span><span class="n">cross_col_deg</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cross_col_deg</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.dc" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">dc</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">coeff_index</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nhbd</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Computes the density coefficient of the graph induced by 
    the neighbourhood of center in matrix</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>matrix</code></td>
          <td>
                <code>2d-array</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>center</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The index of the vertex whose neighbourhood is to be considered, default=0</p>
            </div>
          </td>
          <td>
                <code>0</code>
          </td>
        </tr>
        <tr>
          <td><code>coeff_index</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The dimension to be computed, default=2</p>
            </div>
          </td>
          <td>
                <code>2</code>
          </td>
        </tr>
        <tr>
          <td><code>nhbd</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If true then is assumed that matrix is the neighbourhood of center. 
 If false the neighbourhood of center is computed and used, default= True.</p>
            </div>
          </td>
          <td>
                <code>True</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>float</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The density coefficient of the neighbourhood of center</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1645</span>
<span class="normal">1646</span>
<span class="normal">1647</span>
<span class="normal">1648</span>
<span class="normal">1649</span>
<span class="normal">1650</span>
<span class="normal">1651</span>
<span class="normal">1652</span>
<span class="normal">1653</span>
<span class="normal">1654</span>
<span class="normal">1655</span>
<span class="normal">1656</span>
<span class="normal">1657</span>
<span class="normal">1658</span>
<span class="normal">1659</span>
<span class="normal">1660</span>
<span class="normal">1661</span>
<span class="normal">1662</span>
<span class="normal">1663</span>
<span class="normal">1664</span>
<span class="normal">1665</span>
<span class="normal">1666</span>
<span class="normal">1667</span>
<span class="normal">1668</span>
<span class="normal">1669</span>
<span class="normal">1670</span>
<span class="normal">1671</span>
<span class="normal">1672</span>
<span class="normal">1673</span>
<span class="normal">1674</span>
<span class="normal">1675</span>
<span class="normal">1676</span>
<span class="normal">1677</span>
<span class="normal">1678</span>
<span class="normal">1679</span>
<span class="normal">1680</span>
<span class="normal">1681</span>
<span class="normal">1682</span>
<span class="normal">1683</span>
<span class="normal">1684</span>
<span class="normal">1685</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">dc</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">coeff_index</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nhbd</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the density coefficient of the graph induced by </span>
<span class="sd">            the neighbourhood of center in matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        matrix : 2d-array</span>
<span class="sd">            Adjacency matrix of a directed network.</span>
<span class="sd">        center : int</span>
<span class="sd">            The index of the vertex whose neighbourhood is to be considered, default=0</span>
<span class="sd">        coeff_index : int</span>
<span class="sd">             The dimension to be computed, default=2</span>
<span class="sd">        nhbd : bool</span>
<span class="sd">             If true then is assumed that matrix is the neighbourhood of center. </span>
<span class="sd">             If false the neighbourhood of center is computed and used, default= True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The density coefficient of the neighbourhood of center</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">coeff_index</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Assertion error: Density coefficient must be at least 2&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nhbd</span><span class="p">:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">neighbourhood</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">flagser_output</span> <span class="o">=</span> <span class="n">node_participation</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=</span><span class="n">coeff_index</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">center</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flagser_output</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">coeff_index</span><span class="p">:</span>
        <span class="n">density_coeff</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">flagser_output</span><span class="p">[</span><span class="n">coeff_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">density_coeff</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">coeff_index</span><span class="o">*</span><span class="n">flagser_output</span><span class="p">[</span><span class="n">coeff_index</span><span class="p">]</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">coeff_index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span><span class="o">-</span><span class="n">coeff_index</span><span class="p">)</span><span class="o">*</span><span class="n">flagser_output</span><span class="p">[</span><span class="n">coeff_index</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">density_coeff</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">density_coeff</span> <span class="o">=</span> <span class="n">numerator</span><span class="o">/</span><span class="n">denominator</span>
    <span class="k">return</span> <span class="n">density_coeff</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.edge_participation" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">edge_participation</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="n">return_simplex_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Compute the number of simplex motifs in the network adj each edge is part of.
See simplex_counts for details.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.
The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>node_properties</code></td>
          <td>
                <code>dataframe</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If False (default) counts all simplices in adj.
If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension up to which simplex motifs are counted.
The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</p>
            </div>
          </td>
          <td>
                <code>-1</code>
          </td>
        </tr>
        <tr>
          <td><code>simplex_type</code></td>
          <td>
                <code>string</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Type of simplex to consider:</p>
<p>’directed’ - directed simplices</p>
<p>’undirected’ - simplices in the underlying undirected graph</p>
<p>’reciprocal’ - simplices in the undirected graph of reciprocal connections</p>
            </div>
          </td>
          <td>
                <code>&#39;directed&#39;</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>data frame</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Indexed by the edges in adj and with columns de dimension for which node participation is counted</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj has non-zero entries in the diagonal which can produce errors.</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj is not square.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">edge_participation</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="n">return_simplex_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the number of simplex motifs in the network adj each edge is part of.</span>
<span class="sd">    See simplex_counts for details.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d array or sparse matrix</span>
<span class="sd">        Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.</span>
<span class="sd">        The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    node_properties : dataframe</span>
<span class="sd">        Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</span>
<span class="sd">    max_simplices : bool</span>
<span class="sd">        If False (default) counts all simplices in adj.</span>
<span class="sd">        If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension up to which simplex motifs are counted.</span>
<span class="sd">        The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</span>
<span class="sd">    simplex_type : string</span>
<span class="sd">        Type of simplex to consider:</span>

<span class="sd">        ’directed’ - directed simplices</span>

<span class="sd">        ’undirected’ - simplices in the underlying undirected graph</span>

<span class="sd">        ’reciprocal’ - simplices in the undirected graph of reciprocal connections</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data frame</span>
<span class="sd">        Indexed by the edges in adj and with columns de dimension for which node participation is counted</span>

<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj has non-zero entries in the diagonal which can produce errors.</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj is not square.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;The diagonal of the matrix is non-zero and this may lead to errors!&#39;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">N</span> <span class="o">==</span> <span class="n">M</span><span class="p">,</span> <span class="s1">&#39;Dimension mismatch. The matrix must be square.&#39;</span>


    <span class="c1">#Symmetrize matrix if simplex_type is not &#39;directed&#39;</span>
    <span class="k">if</span> <span class="n">simplex_type</span><span class="o">==</span><span class="s1">&#39;undirected&#39;</span><span class="p">:</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">underlying_undirected_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span> <span class="c1">#symmtrize and keep upper triangular only</span>
    <span class="k">elif</span> <span class="n">simplex_type</span><span class="o">==</span><span class="s2">&quot;reciprocal&quot;</span><span class="p">:</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">rc_submatrix</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span> <span class="c1">#symmtrize and keep upper triangular only</span>

    <span class="n">flagser_out</span> <span class="o">=</span> <span class="n">pyflagsercount</span><span class="o">.</span><span class="n">flagser_count</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">edge_containment</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span>
                                     <span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Done running flagser&quot;</span><span class="p">)</span>
    <span class="n">e_contain</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">flagser_out</span><span class="p">[</span><span class="s1">&#39;edge_contain_counts&#39;</span><span class="p">],</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_simplex_counts</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e_contain</span><span class="p">,</span> <span class="n">flagser_out</span><span class="p">[</span><span class="s2">&quot;cell_counts&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e_contain</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.euler_characteristic" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">euler_characteristic</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Computes the Euler characteristic of the flag complex of the graph with adjacency matrix matrix</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>matrix</code></td>
          <td>
                <code>2d-array</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>integer</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The Euler characteristic of the flag complex of matrix</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1586</span>
<span class="normal">1587</span>
<span class="normal">1588</span>
<span class="normal">1589</span>
<span class="normal">1590</span>
<span class="normal">1591</span>
<span class="normal">1592</span>
<span class="normal">1593</span>
<span class="normal">1594</span>
<span class="normal">1595</span>
<span class="normal">1596</span>
<span class="normal">1597</span>
<span class="normal">1598</span>
<span class="normal">1599</span>
<span class="normal">1600</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">euler_characteristic</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the Euler characteristic of the flag complex of the graph with adjacency matrix matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : 2d-array</span>
<span class="sd">            Adjacency matrix of a directed network.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integer</span>
<span class="sd">            The Euler characteristic of the flag complex of matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pyflagsercount</span><span class="o">.</span><span class="n">flagser_count</span><span class="p">(</span><span class="n">M</span><span class="p">)[</span><span class="s1">&#39;euler&#39;</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.extract_submatrices_from_edge_participation" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">extract_submatrices_from_edge_participation</span><span class="p">(</span><span class="n">edge_par</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Generate binary submatrix of an NxN matrix of edges with edge participation greater than thresh.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>edge_par</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>DataFrame with edge participation values formatted as the output of <code>edge_participation</code> i.e.,
indexed by the edges in adj and with columns de dimension for which edge participation is counted</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dims</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>dimensions of the simplices to consider, if <code>None</code> all positive dimensions are considered</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>N</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Number of nodes in original graph defining the NxN matrix.
The indices of edge_par must be smaller than N</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>thresh</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Threshold value at which to consider an edge.  If thresh=1 all edges that
elong to at least one simplex are considered.</p>
            </div>
          </td>
          <td>
                <code>1</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>dict</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>keys: dimensions
values: sparse binary matrices in coo format of shape (N,N) with entries <code>True</code> corresponding to edges
that belong to at least thresh simplices of the dimension in its corresponding key.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">extract_submatrices_from_edge_participation</span><span class="p">(</span><span class="n">edge_par</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate binary submatrix of an NxN matrix of edges with edge participation greater than thresh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    edge_par: DataFrame</span>
<span class="sd">        DataFrame with edge participation values formatted as the output of ``edge_participation`` i.e.,</span>
<span class="sd">        indexed by the edges in adj and with columns de dimension for which edge participation is counted</span>
<span class="sd">    dims: list of ints</span>
<span class="sd">        dimensions of the simplices to consider, if ``None`` all positive dimensions are considered</span>
<span class="sd">    N: int</span>
<span class="sd">        Number of nodes in original graph defining the NxN matrix.</span>
<span class="sd">        The indices of edge_par must be smaller than N</span>
<span class="sd">    thresh: int</span>
<span class="sd">        Threshold value at which to consider an edge.  If thresh=1 all edges that</span>
<span class="sd">        elong to at least one simplex are considered.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        keys: dimensions</span>
<span class="sd">        values: sparse binary matrices in coo format of shape (N,N) with entries `True` corresponding to edges</span>
<span class="sd">        that belong to at least thresh simplices of the dimension in its corresponding key.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">edge_par</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span>
                   <span class="n">edge_par</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;The array dims shoulds be a subset of the columns of edge participation&quot;</span>
    <span class="n">mats</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Reformat edge_participation (Maybe already do this in the output of edge_participation?)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">edge_par</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">edge_par</span><span class="o">.</span><span class="n">index</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">]</span>
        <span class="n">mats</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;dimension_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)),</span> <span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">col</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="nb">bool</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mats</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.extract_submatrix_from_simplex_list" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">extract_submatrix_from_simplex_list</span><span class="p">(</span><span class="n">simplex_list</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s1">&#39;spine&#39;</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Generate binary submatrix of NxN matrix of edges in simplex list.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>simplex</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Array of dimension (no. of simplices, dimension).
Each row corresponds to a list of nodes on a simplex
indexed by the order of the nodes in an NxN matrix.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>N</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Number of nodes in original graph defining the NxN matrix.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>position</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Position of the edges to extract</p>
<p>'all': all edges of the simplex (it is more efficient to do this with <code>extract_submatrix_from_edge_par</code>)</p>
<p>'spine': edges along the spine of the simplex
(only makes sense for directed simplices)</p>
            </div>
          </td>
          <td>
                <code>&#39;spine&#39;</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>coo bool matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Matrix with of shape (N,N) with entries <code>True</code> corresponding to edges in simplices.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">960</span>
<span class="normal">961</span>
<span class="normal">962</span>
<span class="normal">963</span>
<span class="normal">964</span>
<span class="normal">965</span>
<span class="normal">966</span>
<span class="normal">967</span>
<span class="normal">968</span>
<span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span>
<span class="normal">974</span>
<span class="normal">975</span>
<span class="normal">976</span>
<span class="normal">977</span>
<span class="normal">978</span>
<span class="normal">979</span>
<span class="normal">980</span>
<span class="normal">981</span>
<span class="normal">982</span>
<span class="normal">983</span>
<span class="normal">984</span>
<span class="normal">985</span>
<span class="normal">986</span>
<span class="normal">987</span>
<span class="normal">988</span>
<span class="normal">989</span>
<span class="normal">990</span>
<span class="normal">991</span>
<span class="normal">992</span>
<span class="normal">993</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">extract_submatrix_from_simplex_list</span><span class="p">(</span><span class="n">simplex_list</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s2">&quot;spine&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate binary submatrix of NxN matrix of edges in simplex list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    simplex list: 2d-array</span>
<span class="sd">        Array of dimension (no. of simplices, dimension).</span>
<span class="sd">        Each row corresponds to a list of nodes on a simplex</span>
<span class="sd">        indexed by the order of the nodes in an NxN matrix.</span>
<span class="sd">    N: int</span>
<span class="sd">        Number of nodes in original graph defining the NxN matrix.</span>
<span class="sd">    position: str</span>
<span class="sd">        Position of the edges to extract</span>

<span class="sd">        &#39;all&#39;: all edges of the simplex (it is more efficient to do this with ``extract_submatrix_from_edge_par``)</span>

<span class="sd">        &#39;spine&#39;: edges along the spine of the simplex</span>
<span class="sd">        (only makes sense for directed simplices)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coo bool matrix</span>
<span class="sd">        Matrix with of shape (N,N) with entries `True` corresponding to edges in simplices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">position</span><span class="o">==</span><span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;For edges in any position it is more efficient to use extract_submatrices_from_edge_participation&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">simplex_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>  <span class="c1"># no simplices in this dimension</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">simplex_list</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">edges_abstract</span> <span class="o">=</span> <span class="n">_generate_abstract_edges_in_simplices</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span>
                                                               <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>  <span class="c1"># abstract list of edges to extract from each simplex</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">simplex_list</span><span class="p">[:,</span> <span class="n">edge</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_abstract</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.get_all_simplices_from_max" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">get_all_simplices_from_max</span><span class="p">(</span><span class="n">max_simplices</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Takes the list of maximal simplices are returns the list of all simplices.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>list</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>A list of lists of tuples. Where max_simplices[k] is a list of the 0 dimensional maximal simplices,
where each simplex is a tuple of the vertices of the simplex</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>list</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>A list of lists of tuples. Of the same format as the inputted list but now contains all simplices.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1527</span>
<span class="normal">1528</span>
<span class="normal">1529</span>
<span class="normal">1530</span>
<span class="normal">1531</span>
<span class="normal">1532</span>
<span class="normal">1533</span>
<span class="normal">1534</span>
<span class="normal">1535</span>
<span class="normal">1536</span>
<span class="normal">1537</span>
<span class="normal">1538</span>
<span class="normal">1539</span>
<span class="normal">1540</span>
<span class="normal">1541</span>
<span class="normal">1542</span>
<span class="normal">1543</span>
<span class="normal">1544</span>
<span class="normal">1545</span>
<span class="normal">1546</span>
<span class="normal">1547</span>
<span class="normal">1548</span>
<span class="normal">1549</span>
<span class="normal">1550</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_all_simplices_from_max</span><span class="p">(</span><span class="n">max_simplices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Takes the list of maximal simplices are returns the list of all simplices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_simplices : list</span>
<span class="sd">            A list of lists of tuples. Where max_simplices[k] is a list of the 0 dimensional maximal simplices,</span>
<span class="sd">            where each simplex is a tuple of the vertices of the simplex</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list of lists of tuples. Of the same format as the inputted list but now contains all simplices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">simplices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">max_simplices</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">max_simplices</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">max_simplices</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="n">simplices</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">simplex</span><span class="p">[:</span><span class="n">s</span><span class="p">]</span><span class="o">+</span><span class="n">simplex</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">simplices</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">simplices</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">simplices</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.get_k_skeleta_graph" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">get_k_skeleta_graph</span><span class="p">(</span><span class="n">adj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">simplex_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Return the edges of the (maximal) k-skeleton of the flag complex of adj for all k&lt;= max_dim in the position determined
by position.
If simplex list are provided, it will compute the edges directly from these and not use adj,
in which case N (the number of rows and columns of adj) is required.
If simplex lists are not provided they will be calculated with for the flag complex whose type is determined by
simplex_type as for simplex_counts.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>(N,N)-array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.
The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If False counts all simplices in adj.
If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>dimensions</code></td>
          <td>
                <code>list of ints</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Dimensions <code>k</code> for which the <code>k</code>-skeleta is computed, if None all dimensions are computed.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>simplex_type</code></td>
          <td>
                <code>string</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Type of simplex to consider if computed from adj:</p>
<p>’directed’ - directed simplices</p>
<p>’undirected’ - simplices in the underlying undirected graph</p>
<p>’reciprocal’ - simplices in the undirected graph of reciprocal connections</p>
            </div>
          </td>
          <td>
                <code>&#39;directed&#39;</code>
          </td>
        </tr>
        <tr>
          <td><code>simplex</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Series 2d-arrays indexed by dimension.
Each array is of dimension (no. of simplices, dimension).
Each row corresponds to a list of nodes on a simplex.
If provided adj will be ignored but N will be required.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>N</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Number of nodes in original graph.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>position</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Position of the edges to extract</p>
<p>'all': all edges of the simplex</p>
<p>'spine': edges along the spine of the simplex
(only makes sense if simplices are directed)</p>
            </div>
          </td>
          <td>
                <code>&#39;all&#39;</code>
          </td>
        </tr>
        <tr>
          <td><code>threads</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Number of threads into which the computation should be parallelized</p>
            </div>
          </td>
          <td>
                <code>8</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>dict</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Dictionary with keys dimensions and values boolean (N,N) matrices with entries <code>True</code>
corresponding to edges in (maximal) simplices of that dimension.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If neither adj nor simplex_list are provided</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If N &lt;= than an entry in the simplex list</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If a dimension is required that is not an index in the simplex list</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

<details class="note" open>
  <summary>Notes</summary>
  <p>In order to list k-simplices and thus the k-skeleton, flagsercount needs to list all lower
dimensional simplices anyhow.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_k_skeleta_graph</span><span class="p">(</span><span class="n">adj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">simplex_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                        <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the edges of the (maximal) k-skeleton of the flag complex of adj for all k&lt;= max_dim in the position determined</span>
<span class="sd">    by position.</span>
<span class="sd">    If simplex list are provided, it will compute the edges directly from these and not use adj,</span>
<span class="sd">    in which case N (the number of rows and columns of adj) is required.</span>
<span class="sd">    If simplex lists are not provided they will be calculated with for the flag complex whose type is determined by</span>
<span class="sd">    simplex_type as for simplex_counts.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : (N,N)-array or sparse matrix</span>
<span class="sd">        Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.</span>
<span class="sd">        The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    max_simplices : bool</span>
<span class="sd">        If False counts all simplices in adj.</span>
<span class="sd">        If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</span>
<span class="sd">    dimensions : list of ints</span>
<span class="sd">        Dimensions `k` for which the `k`-skeleta is computed, if None all dimensions are computed.</span>
<span class="sd">    simplex_type : string</span>
<span class="sd">        Type of simplex to consider if computed from adj:</span>

<span class="sd">        ’directed’ - directed simplices</span>

<span class="sd">        ’undirected’ - simplices in the underlying undirected graph</span>

<span class="sd">        ’reciprocal’ - simplices in the undirected graph of reciprocal connections</span>
<span class="sd">    simplex list: series</span>
<span class="sd">        Series 2d-arrays indexed by dimension.</span>
<span class="sd">        Each array is of dimension (no. of simplices, dimension).</span>
<span class="sd">        Each row corresponds to a list of nodes on a simplex.</span>
<span class="sd">        If provided adj will be ignored but N will be required.</span>
<span class="sd">    N: int</span>
<span class="sd">        Number of nodes in original graph.</span>
<span class="sd">    position: str</span>
<span class="sd">        Position of the edges to extract</span>

<span class="sd">        &#39;all&#39;: all edges of the simplex</span>

<span class="sd">        &#39;spine&#39;: edges along the spine of the simplex</span>
<span class="sd">        (only makes sense if simplices are directed)</span>
<span class="sd">    threads: int</span>
<span class="sd">        Number of threads into which the computation should be parallelized</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary with keys dimensions and values boolean (N,N) matrices with entries `True`</span>
<span class="sd">        corresponding to edges in (maximal) simplices of that dimension.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If neither adj nor simplex_list are provided</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If N &lt;= than an entry in the simplex list</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If a dimension is required that is not an index in the simplex list</span>

<span class="sd">    Notes</span>
<span class="sd">    ------</span>
<span class="sd">    In order to list k-simplices and thus the k-skeleton, flagsercount needs to list all lower</span>
<span class="sd">    dimensional simplices anyhow.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if enough inputs are provided</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">position</span> <span class="o">==</span> <span class="s1">&#39;spine&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">simplex_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">not_precomputed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">position</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">edge_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">not_precomputed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">not_precomputed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">adj</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">not_precomputed</span><span class="p">),</span> <span class="s2">&quot;Either adj or simplex_list/edge_participation need to be provided&quot;</span>

    <span class="c1"># Determine dimensions</span>
    <span class="k">if</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>
    <span class="c1"># Compute simplex list or edge particiption if not precomputed</span>
    <span class="k">if</span> <span class="n">not_precomputed</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;spine&quot;</span><span class="p">:</span>  <span class="c1"># Compute simplex since they are not provided</span>
            <span class="n">simplex_list</span> <span class="o">=</span> <span class="n">list_simplices_by_dimension</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                       <span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span>
                                                       <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span>
                                                       <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>  <span class="c1"># More efficient than going from simplex lists if the position is not important</span>
            <span class="n">edge_par</span><span class="p">,</span> <span class="n">simplex_counts</span> <span class="o">=</span> <span class="n">edge_participation</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span>
                                                          <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="n">simplex_type</span><span class="p">,</span>
                                                          <span class="n">return_simplex_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;spine&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">simplex_list</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span><span class="o">.</span><span class="n">explode</span><span class="p">()),</span> \
                <span class="s2">&quot;N must be larger than all the entries in the simplex list&quot;</span>
    <span class="c1"># Extract &#39;k&#39;-skeleton</span>
    <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;spine&quot;</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">simplex_list</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">simplex_list</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Doesn&#39;t make sense to look at the 0-skeleton</span>
    <span class="k">elif</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">edge_par</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dim&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dimensions</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)]</span>
    <span class="n">skeleton_mats</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;dimension_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;spine&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simplex_list</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">simplex_list</span><span class="p">[</span><span class="n">dim</span><span class="p">]),</span> \
                    <span class="s2">&quot;N must be larger than all the entries in the simplex list&quot;</span>
                <span class="n">skeleton_mats</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;dimension_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_submatrix_from_simplex_list</span><span class="p">(</span><span class="n">simplex_list</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">N</span><span class="p">,</span>
                                                                                        <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">skeleton_mats</span> <span class="o">=</span> <span class="n">extract_submatrices_from_edge_participation</span><span class="p">(</span><span class="n">edge_par</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">skeleton_mats</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.in_degree_from_pop" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">in_degree_from_pop</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">source_pop</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Compute generalized in-degree of nodes source_pop onto the rest of the nodes in adj.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.
The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>source_pop</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If False counts all simplices.
If True counts only maximal simplices.</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension up to which simplex motifs are counted.
The default max_dim = -1 counts all existing dimensions.
Particularly useful for large or dense graphs.</p>
            </div>
          </td>
          <td>
                <code>-1</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>Data frame</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Table of k-in-degrees from source_pop indexed by the target population.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj restricted to source_pop has non-zero entries in the diagonal which can produce errors.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">in_degree_from_pop</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">source_pop</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># TODO: DO THE OUTDEGREE VERSION</span>
    <span class="c1"># TODO: Get participation directly from flagsercount via vertices to do?</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute generalized in-degree of nodes source_pop onto the rest of the nodes in adj.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj: 2d (N,N)-array or sparse matrix</span>
<span class="sd">        Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.</span>
<span class="sd">        The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    source_pop: list of indices of the source population, must be a subset of ``np.arange(0, adj.shape[0])``</span>
<span class="sd">    max_simplices : bool</span>
<span class="sd">        If False counts all simplices.</span>
<span class="sd">        If True counts only maximal simplices.</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension up to which simplex motifs are counted.</span>
<span class="sd">        The default max_dim = -1 counts all existing dimensions.</span>
<span class="sd">        Particularly useful for large or dense graphs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Data frame</span>
<span class="sd">        Table of k-in-degrees from source_pop indexed by the target population.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj restricted to source_pop has non-zero entries in the diagonal which can produce errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adj</span><span class="o">=</span><span class="n">adj</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    <span class="n">source_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">source_pop</span><span class="p">)</span>
    <span class="n">target_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">source_pop</span><span class="p">)</span>
    <span class="n">adj_source</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">source_pop</span><span class="p">,</span> <span class="n">source_pop</span><span class="p">)]</span>
    <span class="n">adj_cross</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">source_pop</span><span class="p">,</span> <span class="n">target_pop</span><span class="p">)]</span>
    <span class="n">degs</span><span class="o">=</span><span class="n">cross_col_k_in_degree</span><span class="p">(</span><span class="n">adj_cross</span><span class="p">,</span> <span class="n">adj_source</span><span class="p">,</span>
                                 <span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span><span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">degs</span><span class="o">.</span><span class="n">index</span><span class="o">=</span><span class="n">target_pop</span>
    <span class="k">return</span> <span class="n">degs</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.list_simplices_by_dimension" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">list_simplices_by_dimension</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>List all simplex motifs in the network adj.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d (N,N)-array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.
The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>node_properties</code></td>
          <td>
                <code> data frame</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If False counts all simplices in adj.
If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension up to which simplex motifs are counted.
The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</p>
            </div>
          </td>
          <td>
                <code>-1</code>
          </td>
        </tr>
        <tr>
          <td><code>simplex_type</code></td>
          <td>
                <code>string</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Type of simplex to consider:</p>
<p>’directed’ - directed simplices</p>
<p>’undirected’ - simplices in the underlying undirected graph</p>
<p>’reciprocal’ - simplices in the undirected graph of reciprocal connections</p>
            </div>
          </td>
          <td>
                <code>&#39;directed&#39;</code>
          </td>
        </tr>
        <tr>
          <td><code>nodes</code></td>
          <td>
                <code>1d array or None(default)</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Restrict to list only the simplices whose source node is in nodes.  If None list all simplices</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>series</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Simplex lists indexed per dimension.  The dimension k entry is a (no. of k-simplices, k+1)-array
is given, where each row denotes a simplex.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj has non-zero entries in the diagonal which can produce errors.</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj is not square.</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If nodes is not a subarray of np.arange(N)</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

<details class="see-also" open>
  <summary>See Also</summary>
  <p>simplex_counts : A function that counts the simplices instead of listing them and has descriptions of the
simplex types.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">list_simplices_by_dimension</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;List all simplex motifs in the network adj.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d (N,N)-array or sparse matrix</span>
<span class="sd">        Adjacency matrix of a directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.</span>
<span class="sd">        The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    node_properties :  data frame</span>
<span class="sd">        Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</span>
<span class="sd">    max_simplices : bool</span>
<span class="sd">        If False counts all simplices in adj.</span>
<span class="sd">        If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension up to which simplex motifs are counted.</span>
<span class="sd">        The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</span>
<span class="sd">    simplex_type : string</span>
<span class="sd">        Type of simplex to consider:</span>

<span class="sd">        ’directed’ - directed simplices</span>

<span class="sd">        ’undirected’ - simplices in the underlying undirected graph</span>

<span class="sd">        ’reciprocal’ - simplices in the undirected graph of reciprocal connections</span>
<span class="sd">    nodes : 1d array or None(default)</span>
<span class="sd">        Restrict to list only the simplices whose source node is in nodes.  If None list all simplices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    series</span>
<span class="sd">        Simplex lists indexed per dimension.  The dimension k entry is a (no. of k-simplices, k+1)-array</span>
<span class="sd">        is given, where each row denotes a simplex.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj has non-zero entries in the diagonal which can produce errors.</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj is not square.</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If nodes is not a subarray of np.arange(N)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    simplex_counts : A function that counts the simplices instead of listing them and has descriptions of the</span>
<span class="sd">    simplex types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;COMPUTE list of </span><span class="si">%s</span><span class="s2">simplices by dimension&quot;</span><span class="p">,</span> <span class="s2">&quot;max-&quot;</span> <span class="k">if</span> <span class="n">max_simplices</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">pyflagsercount</span>

    <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;The diagonal of the matrix is non-zero and this may lead to errors!&#39;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">N</span> <span class="o">==</span> <span class="n">M</span><span class="p">,</span> <span class="s1">&#39;Dimension mismatch. The matrix must be square.&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;nodes must be a subarray of the nodes of the matrix&quot;</span>

    <span class="c1">#Symmetrize matrix if simplex_type is not &#39;directed&#39;</span>
    <span class="k">if</span> <span class="n">simplex_type</span><span class="o">==</span><span class="s1">&#39;undirected&#39;</span><span class="p">:</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">underlying_undirected_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span> <span class="c1">#symmtrize and keep upper triangular only</span>
    <span class="k">elif</span> <span class="n">simplex_type</span><span class="o">==</span><span class="s2">&quot;reciprocal&quot;</span><span class="p">:</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">rc_submatrix</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span> <span class="c1">#symmtrize and keep upper triangular only</span>

    <span class="n">n_threads</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;threads&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_threads&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>


    <span class="c1"># Only the simplices that have sources stored in this temporary file will be considered</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="kn">import</span> <span class="nn">os</span>
        <span class="n">tmp_file</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">vertices_todo</span> <span class="o">=</span> <span class="n">tmp_file</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">vertices_todo</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertices_todo</span><span class="o">=</span><span class="s1">&#39;&#39;</span>

    <span class="c1">#Generate simplex_list</span>
    <span class="n">original</span><span class="o">=</span><span class="n">pyflagsercount</span><span class="o">.</span><span class="n">flagser_count</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span><span class="n">threads</span><span class="o">=</span><span class="n">n_threads</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span>
                                      <span class="n">vertices_todo</span><span class="o">=</span><span class="n">vertices_todo</span><span class="p">,</span> <span class="n">return_simplices</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="s1">&#39;simplices&#39;</span><span class="p">]</span>

    <span class="c1">#Remove temporary file</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vertices_todo</span><span class="p">)</span>

    <span class="c1">#Format output</span>
    <span class="n">max_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_dim</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dim&quot;</span><span class="p">)</span>
    <span class="n">simplices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;simplices&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
    <span class="c1">#When counting all simplices flagser doesn&#39;t list dim 0 and 1 because they correspond to vertices and edges</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">max_simplices</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        <span class="n">coom</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
        <span class="n">simplices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">coom</span><span class="o">.</span><span class="n">row</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">simplices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">coom</span><span class="o">.</span><span class="n">row</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">coom</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">mask</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">simplices</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.nbc" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">nbc</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Computes the normalised Betti coefficient of the graph with adjacency matrix matrix</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>matrix</code></td>
          <td>
                <code>2d-array</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>float</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The normalised Betti coefficient of the graph with adjacency matrix matrix</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1711</span>
<span class="normal">1712</span>
<span class="normal">1713</span>
<span class="normal">1714</span>
<span class="normal">1715</span>
<span class="normal">1716</span>
<span class="normal">1717</span>
<span class="normal">1718</span>
<span class="normal">1719</span>
<span class="normal">1720</span>
<span class="normal">1721</span>
<span class="normal">1722</span>
<span class="normal">1723</span>
<span class="normal">1724</span>
<span class="normal">1725</span>
<span class="normal">1726</span>
<span class="normal">1727</span>
<span class="normal">1728</span>
<span class="normal">1729</span>
<span class="normal">1730</span>
<span class="normal">1731</span>
<span class="normal">1732</span>
<span class="normal">1733</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">nbc</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the normalised Betti coefficient of the graph with adjacency matrix matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : 2d-array</span>
<span class="sd">            Adjacency matrix of a directed network.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The normalised Betti coefficient of the graph with adjacency matrix matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flagser_output</span> <span class="o">=</span> <span class="n">pyflagser</span><span class="o">.</span><span class="n">flagser_unweighted</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="n">flagser_output</span><span class="p">[</span><span class="s1">&#39;cell_count&#39;</span><span class="p">]</span>
    <span class="n">bettis</span> <span class="o">=</span> <span class="n">flagser_output</span><span class="p">[</span><span class="s1">&#39;betti&#39;</span><span class="p">]</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">bettis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bettis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">bettis</span> <span class="o">=</span> <span class="n">bettis</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">normalized_betti_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">bettis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bettis</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)))]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">normalized_betti_list</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.node_degree" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">node_degree</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Compute degree of nodes in network adj</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j
of weight adj[i,j].</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>node_properties</code></td>
          <td>
                <code>data frame</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Data frame of neuron properties in adj. Only necessary if used in conjunction with TAP or connectome utilities.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>direction</code></td>
          <td>
                <code>string or tuple of strings</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Direction for which to compute the degree</p>
<p>'IN' - In degree</p>
<p>'OUT'- Out degree</p>
<p>None or ('IN', 'OUT') - Total degree i.e. IN+OUT</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>series or data frame</code>
          </td>
          <td>
            <div class="doc-md-description">
              
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>Warning</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj has non-zero entries in the diagonal</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If direction is invalid</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">node_degree</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute degree of nodes in network adj</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d array or sparse matrix</span>
<span class="sd">        Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j</span>
<span class="sd">        of weight adj[i,j].</span>
<span class="sd">    node_properties : data frame</span>
<span class="sd">        Data frame of neuron properties in adj. Only necessary if used in conjunction with TAP or connectome utilities.</span>
<span class="sd">    direction : string or tuple of strings</span>
<span class="sd">        Direction for which to compute the degree</span>

<span class="sd">        &#39;IN&#39; - In degree</span>

<span class="sd">        &#39;OUT&#39;- Out degree</span>

<span class="sd">        None or (&#39;IN&#39;, &#39;OUT&#39;) - Total degree i.e. IN+OUT</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    series or data frame</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Warning</span>
<span class="sd">        If adj has non-zero entries in the diagonal</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If direction is invalid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">direction</span> <span class="ow">or</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;IN&quot;</span><span class="p">,</span> <span class="s2">&quot;OUT&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s2">&quot;IN&quot;</span><span class="p">,</span> <span class="s2">&quot;OUT&quot;</span><span class="p">),</span>\
        <span class="sa">f</span><span class="s2">&quot;Invalid `direction`: </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span> <span class="n">ndarray</span><span class="p">):</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">matrix</span><span class="o">=</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">weighted</span><span class="p">:</span>
        <span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">matrix</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;The diagonal is non-zero!  This may cause errors in the analysis&#39;</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;node&quot;</span><span class="p">)</span>
    <span class="n">series</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">in_degree</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">series</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">out_degree</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">series</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">direction</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">in_degree</span><span class="p">()</span> <span class="o">+</span> <span class="n">out_degree</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s2">&quot;IN&quot;</span><span class="p">,</span> <span class="s2">&quot;OUT&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;IN&quot;</span><span class="p">:</span> <span class="n">in_degree</span><span class="p">(),</span> <span class="s2">&quot;OUT&quot;</span><span class="p">:</span> <span class="n">out_degree</span><span class="p">()})</span>

    <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s2">&quot;OUT&quot;</span><span class="p">,</span> <span class="s2">&quot;IN&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;OUT&quot;</span><span class="p">:</span> <span class="n">out_degree</span><span class="p">(),</span> <span class="s2">&quot;IN&quot;</span><span class="p">:</span> <span class="n">in_degree</span><span class="p">()})</span>

    <span class="k">return</span> <span class="n">in_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;IN&quot;</span> <span class="k">else</span> <span class="n">out_degree</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.node_k_degree" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">node_k_degree</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;IN&#39;</span><span class="p">,</span> <span class="s1">&#39;OUT&#39;</span><span class="p">),</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Compute generalized degree of nodes in network adj.  The k-(in/out)-degree of a node v is the number of
k-simplices with all its nodes mapping to/from the node v.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j
of weight adj[i,j].  The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>node_properties</code></td>
          <td>
                <code>dataframe</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>direction</code></td>
          <td>
                <code>string</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Direction for which to compute the degree</p>
<p>'IN' - In degree</p>
<p>'OUT'- Out degree</p>
<p>(’IN’, ’OUT’) - both</p>
            </div>
          </td>
          <td>
                <code>(&#39;IN&#39;, &#39;OUT&#39;)</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension for which to compute the degree max_dim &gt;=2 or -1 in
which case it computes all dimensions.</p>
            </div>
          </td>
          <td>
                <code>-1</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>data frame</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Table of of k-(in/out)-degrees</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>Warning</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj has non-zero entries in the diagonal which are ignored in the analysis</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If direction is invalid</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If not max_dim &gt;1</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

<details class="note" open>
  <summary>Notes</summary>
  <p>Note that the k-in-degree of a node v is the number of (k+1) simplices the node v is a sink of.
Dually, the k-out-degree of a node v is the number of (k+1) simplices the node v is a source of.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">node_k_degree</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;IN&quot;</span><span class="p">,</span> <span class="s2">&quot;OUT&quot;</span><span class="p">),</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1">#TODO: Generalize from one population to another</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute generalized degree of nodes in network adj.  The k-(in/out)-degree of a node v is the number of</span>
<span class="sd">    k-simplices with all its nodes mapping to/from the node v.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d array or sparse matrix</span>
<span class="sd">        Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j</span>
<span class="sd">        of weight adj[i,j].  The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    node_properties : dataframe</span>
<span class="sd">        Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</span>
<span class="sd">    direction : string</span>
<span class="sd">        Direction for which to compute the degree</span>

<span class="sd">        &#39;IN&#39; - In degree</span>

<span class="sd">        &#39;OUT&#39;- Out degree</span>

<span class="sd">        (’IN’, ’OUT’) - both</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension for which to compute the degree max_dim &gt;=2 or -1 in</span>
<span class="sd">        which case it computes all dimensions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data frame</span>
<span class="sd">        Table of of k-(in/out)-degrees</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Warning</span>
<span class="sd">        If adj has non-zero entries in the diagonal which are ignored in the analysis</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If direction is invalid</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If not max_dim &gt;1</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note that the k-in-degree of a node v is the number of (k+1) simplices the node v is a sink of.</span>
<span class="sd">    Dually, the k-out-degree of a node v is the number of (k+1) simplices the node v is a source of.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">max_dim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">max_dim</span><span class="o">==-</span><span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;max_dim should be &gt;=2&quot;</span>
    <span class="k">assert</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;IN&quot;</span><span class="p">,</span> <span class="s2">&quot;OUT&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s2">&quot;IN&quot;</span><span class="p">,</span> <span class="s2">&quot;OUT&quot;</span><span class="p">),</span> \
        <span class="sa">f</span><span class="s2">&quot;Invalid `direction`: </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;The diagonal is non-zero!  Non-zero entries in the diagonal will be ignored.&#39;</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">pyflagsercount</span>
    <span class="n">flagser_out</span> <span class="o">=</span> <span class="n">pyflagsercount</span><span class="o">.</span><span class="n">flagser_count</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">return_simplices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">)</span>
    <span class="n">max_dim_possible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flagser_out</span><span class="p">[</span><span class="s1">&#39;cell_counts&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">max_dim</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">max_dim</span> <span class="o">=</span> <span class="n">max_dim_possible</span>
    <span class="k">elif</span> <span class="n">max_dim</span> <span class="o">&gt;</span> <span class="n">max_dim_possible</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The maximum dimension selected is not attained&quot;</span><span class="p">)</span>
        <span class="n">max_dim</span> <span class="o">=</span> <span class="n">max_dim_possible</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">max_dim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">max_dim</span><span class="o">!=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are no simplices of dimension 2 or higher&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;node&quot;</span><span class="p">)</span>
        <span class="n">generalized_degree</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;OUT&quot;</span> <span class="ow">in</span> <span class="n">direction</span><span class="p">:</span>
                <span class="c1"># getting source participation across dimensions</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flagser_out</span><span class="p">[</span><span class="s1">&#39;simplices&#39;</span><span class="p">][</span><span class="n">dim</span><span class="p">])[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">generalized_degree</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">_out_degree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;IN&quot;</span> <span class="ow">in</span> <span class="n">direction</span><span class="p">:</span>
                <span class="c1"># getting sink participation across dimensions</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flagser_out</span><span class="p">[</span><span class="s1">&#39;simplices&#39;</span><span class="p">][</span><span class="n">dim</span><span class="p">])[:,</span> <span class="n">dim</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">generalized_degree</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s1">_in_degree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">generalized_degree</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.node_participation" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">node_participation</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Compute the number of simplex motifs in the network adj each node is part of.
See simplex_counts for details.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.
The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>node_properties</code></td>
          <td>
                <code>dataframe</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If False (default) counts all simplices in adj.
If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension up to which simplex motifs are counted.
The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</p>
            </div>
          </td>
          <td>
                <code>-1</code>
          </td>
        </tr>
        <tr>
          <td><code>simplex_type</code></td>
          <td>
                <code>string</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Type of simplex to consider:</p>
<p>’directed’ - directed simplices</p>
<p>’undirected’ - simplices in the underlying undirected graph</p>
<p>’reciprocal’ - simplices in the undirected graph of reciprocal connections</p>
            </div>
          </td>
          <td>
                <code>&#39;directed&#39;</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>data frame</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Indexed by the nodes in adj and with columns de dimension for which node participation is counted</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj has non-zero entries in the diagonal which can produce errors.</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj is not square.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">node_participation</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the number of simplex motifs in the network adj each node is part of.</span>
<span class="sd">    See simplex_counts for details.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d array or sparse matrix</span>
<span class="sd">        Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.</span>
<span class="sd">        The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    node_properties : dataframe</span>
<span class="sd">        Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</span>
<span class="sd">    max_simplices : bool</span>
<span class="sd">        If False (default) counts all simplices in adj.</span>
<span class="sd">        If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension up to which simplex motifs are counted.</span>
<span class="sd">        The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</span>
<span class="sd">    simplex_type : string</span>
<span class="sd">        Type of simplex to consider:</span>

<span class="sd">        ’directed’ - directed simplices</span>

<span class="sd">        ’undirected’ - simplices in the underlying undirected graph</span>

<span class="sd">        ’reciprocal’ - simplices in the undirected graph of reciprocal connections</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data frame</span>
<span class="sd">        Indexed by the nodes in adj and with columns de dimension for which node participation is counted</span>

<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj has non-zero entries in the diagonal which can produce errors.</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj is not square.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;The diagonal of the matrix is non-zero and this may lead to errors!&#39;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">N</span> <span class="o">==</span> <span class="n">M</span><span class="p">,</span> <span class="s1">&#39;Dimension mismatch. The matrix must be square.&#39;</span>


    <span class="c1">#Symmetrize matrix if simplex_type is not &#39;directed&#39;</span>
    <span class="k">if</span> <span class="n">simplex_type</span><span class="o">==</span><span class="s1">&#39;undirected&#39;</span><span class="p">:</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">underlying_undirected_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span> <span class="c1">#symmtrize and keep upper triangular only</span>
    <span class="k">elif</span> <span class="n">simplex_type</span><span class="o">==</span><span class="s2">&quot;reciprocal&quot;</span><span class="p">:</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">rc_submatrix</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span> <span class="c1">#symmtrize and keep upper triangular only</span>

    <span class="n">flagser_counts</span> <span class="o">=</span> <span class="n">_flagser_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">count_node_participation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span>
                                     <span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flagser_counts</span><span class="p">[</span><span class="s2">&quot;node_participation&quot;</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.normalised_simplex_count" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">normalised_simplex_count</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Computes the normalised simplex count of the flag complex of the graph with adjacency matrix matrix</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>matrix</code></td>
          <td>
                <code>2d-array</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The dimension to be computed, default=2</p>
            </div>
          </td>
          <td>
                <code>2</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>float</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The normalised simplex count of dimension dim of the flag complex of matrix</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1691</span>
<span class="normal">1692</span>
<span class="normal">1693</span>
<span class="normal">1694</span>
<span class="normal">1695</span>
<span class="normal">1696</span>
<span class="normal">1697</span>
<span class="normal">1698</span>
<span class="normal">1699</span>
<span class="normal">1700</span>
<span class="normal">1701</span>
<span class="normal">1702</span>
<span class="normal">1703</span>
<span class="normal">1704</span>
<span class="normal">1705</span>
<span class="normal">1706</span>
<span class="normal">1707</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">normalised_simplex_count</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the normalised simplex count of the flag complex of the graph with adjacency matrix matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : 2d-array</span>
<span class="sd">            Adjacency matrix of a directed network.</span>
<span class="sd">        dim : int</span>
<span class="sd">             The dimension to be computed, default=2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The normalised simplex count of dimension dim of the flag complex of matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">normalized_simplex_counts</span><span class="p">(</span><span class="n">matrix</span><span class="p">)[</span><span class="n">dim</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.normalized_simplex_counts" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">normalized_simplex_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Compute the ratio of directed/undirected simplex counts normalized to be between 0 and 1.
See simplex_counts and undirected_simplex_counts for details.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j
of weight adj[i,j].  The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>node_properties</code></td>
          <td>
                <code>dataframe</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If False counts all simplices in adj.
If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension up to which simplex motifs are counted.
The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</p>
            </div>
          </td>
          <td>
                <code>-1</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>panda series</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Normalized simplex counts</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj has non-zero entries in the diagonal which can produce errors.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

<details class="note" open>
  <summary>Notes</summary>
  <p>Maybe we should say why we choose this metric</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">normalized_simplex_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the ratio of directed/undirected simplex counts normalized to be between 0 and 1.</span>
<span class="sd">    See simplex_counts and undirected_simplex_counts for details.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d array or sparse matrix</span>
<span class="sd">        Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j</span>
<span class="sd">        of weight adj[i,j].  The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    node_properties : dataframe</span>
<span class="sd">        Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</span>
<span class="sd">    max_simplices : bool</span>
<span class="sd">        If False counts all simplices in adj.</span>
<span class="sd">        If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension up to which simplex motifs are counted.</span>
<span class="sd">        The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    panda series</span>
<span class="sd">        Normalized simplex counts</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj has non-zero entries in the diagonal which can produce errors.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Maybe we should say why we choose this metric&quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">factorial</span>
    <span class="n">denominator</span><span class="o">=</span><span class="n">simplex_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="n">node_properties</span><span class="p">,</span><span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span>
                                          <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span><span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;undirected&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="c1">#Global maximum dimension since every directed simplex has an underlying undirected one of the same dimension</span>
    <span class="n">max_dim_global</span><span class="o">=</span><span class="n">denominator</span><span class="o">.</span><span class="n">size</span>
    <span class="c1">#Maximum number of possible directed simplices for each undirected simplex across dimensions</span>
    <span class="n">max_possible_directed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_dim_global</span><span class="p">)])</span>
    <span class="n">denominator</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">denominator</span><span class="p">,</span> <span class="n">max_possible_directed</span><span class="p">)</span>
    <span class="n">numerator</span><span class="o">=</span><span class="n">simplex_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="n">node_properties</span><span class="p">,</span><span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span>
                             <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span><span class="n">simple_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">numerator</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_dim_global</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">numerator</span><span class="p">)),</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_series_by_dim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span><span class="n">denominator</span><span class="p">)[</span><span class="mi">1</span><span class="p">:],</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;normalized_simplex_counts&quot;</span><span class="p">,</span>
                          <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">max_dim_global</span><span class="p">),</span> <span class="n">name_index</span><span class="o">=</span><span class="s2">&quot;dim&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.rc_submatrix" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">rc_submatrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Returns the symmetric submatrix of reciprocal connections of adj</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>symmetric matrix of the same dtype as adj of reciprocal connections</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">rc_submatrix</span><span class="p">(</span><span class="n">adj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the symmetric submatrix of reciprocal connections of adj</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d array or sparse matrix</span>
<span class="sd">        Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sparse matrix</span>
<span class="sd">        symmetric matrix of the same dtype as adj of reciprocal connections</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;The diagonal is non-zero and this may lead to errors!&#39;</span><span class="p">)</span>
    <span class="n">mask</span><span class="o">=</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">mask</span><span class="o">=</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    <span class="n">mask</span><span class="o">.</span><span class="n">eliminate_zeros</span>
    <span class="k">return</span> <span class="n">adj</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.simplex_counts" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">simplex_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Compute the number of simplex motifs in the network adj.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j
of weight adj[i,j].  The matrix can be asymmetric, but must have 0 in the diagonal.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>node_properties</code></td>
          <td>
                <code>dataframe</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If False counts all simplices in adj.
If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_dim</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Maximal dimension up to which simplex motifs are counted.
The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</p>
            </div>
          </td>
          <td>
                <code>-1</code>
          </td>
        </tr>
        <tr>
          <td><code>simplex_type</code></td>
          <td>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Type of simplex to consider (See Notes):</p>
<p>’directed’ - directed simplices</p>
<p>’undirected’ - simplices in the underlying undirected graph</p>
<p>’reciprocal’ - simplices in the undirected graph of reciprocal connections</p>
            </div>
          </td>
          <td>
                <code>&#39;directed&#39;</code>
          </td>
        </tr>
        <tr>
          <td><code>nodes</code></td>
          <td>
                <code>1d array or None(default)</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Restrict to list only the simplices whose source node is in nodes.  If None list all simplices.
This only makes sense for directed simplices.</p>
            </div>
          </td>
          <td>
                <code>None</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>series</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>simplex counts</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Raises:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj has non-zero entries in the diagonal which can produce errors.</p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
                <code>AssertionError</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If adj is not square.</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

<details class="note" open>
  <summary>Notes</summary>
  <p>A directed simplex of dimension k in adj is a set of (k+1) nodes which are all to all connected in a feedforward manner.
That is, they can be ordered from 0 to k such that there is an edge from i to j whenever i &lt; j.</p>
<p>An undirected simplex of dimension k in adj is a set of (k+1) nodes in adj which are all to all connected.  That is, they
are all to all connected in the underlying undirected graph of adj.  In the literature this is also called a (k+1)-clique
of the underlying undirected graph.</p>
<p>A reciprocal simplex of dimension k in adj is a set of (k+1) nodes in adj which are all to all reciprocally connected.
That is, they are all to all connected in the undirected graph of reciprocal connections of adj.  In the literature this is
also called a (k+1)-clique of the undirected graph of reciprocal connections.</p>
</details>
          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">simplex_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">max_simplices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">simplex_type</span><span class="o">=</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># TODO: ADD TRANSPOSE</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the number of simplex motifs in the network adj.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d array or sparse matrix</span>
<span class="sd">        Adjacency matrix of the directed network.  A non-zero entry adj[i,j] implies there is an edge from i to j</span>
<span class="sd">        of weight adj[i,j].  The matrix can be asymmetric, but must have 0 in the diagonal.</span>
<span class="sd">    node_properties : dataframe</span>
<span class="sd">        Data frame of neuron properties in adj.  Only necessary if used in conjunction with TAP or connectome utilities.</span>
<span class="sd">    max_simplices : bool</span>
<span class="sd">        If False counts all simplices in adj.</span>
<span class="sd">        If True counts only maximal simplices i.e., simplex motifs that are not contained in higher dimensional ones.</span>
<span class="sd">    max_dim : int</span>
<span class="sd">        Maximal dimension up to which simplex motifs are counted.</span>
<span class="sd">        The default max_dim = -1 counts all existing dimensions.  Particularly useful for large or dense graphs.</span>
<span class="sd">    simplex_type: string</span>
<span class="sd">        Type of simplex to consider (See Notes):</span>

<span class="sd">        ’directed’ - directed simplices</span>

<span class="sd">        ’undirected’ - simplices in the underlying undirected graph</span>

<span class="sd">        ’reciprocal’ - simplices in the undirected graph of reciprocal connections</span>
<span class="sd">    nodes : 1d array or None(default)</span>
<span class="sd">        Restrict to list only the simplices whose source node is in nodes.  If None list all simplices.</span>
<span class="sd">        This only makes sense for directed simplices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    series</span>
<span class="sd">        simplex counts</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj has non-zero entries in the diagonal which can produce errors.</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If adj is not square.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A directed simplex of dimension k in adj is a set of (k+1) nodes which are all to all connected in a feedforward manner.</span>
<span class="sd">    That is, they can be ordered from 0 to k such that there is an edge from i to j whenever i &lt; j.</span>

<span class="sd">    An undirected simplex of dimension k in adj is a set of (k+1) nodes in adj which are all to all connected.  That is, they</span>
<span class="sd">    are all to all connected in the underlying undirected graph of adj.  In the literature this is also called a (k+1)-clique</span>
<span class="sd">    of the underlying undirected graph.</span>

<span class="sd">    A reciprocal simplex of dimension k in adj is a set of (k+1) nodes in adj which are all to all reciprocally connected.</span>
<span class="sd">    That is, they are all to all connected in the undirected graph of reciprocal connections of adj.  In the literature this is</span>
<span class="sd">    also called a (k+1)-clique of the undirected graph of reciprocal connections.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;The diagonal of the matrix is non-zero and this may lead to errors!&#39;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">N</span> <span class="o">==</span> <span class="n">M</span><span class="p">,</span> <span class="s1">&#39;Dimension mismatch. The matrix must be square.&#39;</span>


    <span class="c1">#Symmetrize matrix if simplex_type is not &#39;directed&#39;</span>
    <span class="k">if</span> <span class="n">simplex_type</span><span class="o">==</span><span class="s1">&#39;undirected&#39;</span><span class="p">:</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">underlying_undirected_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span> <span class="c1">#symmtrize and keep upper triangular only</span>
    <span class="k">elif</span> <span class="n">simplex_type</span><span class="o">==</span><span class="s2">&quot;reciprocal&quot;</span><span class="p">:</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">rc_submatrix</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span> <span class="c1">#symmtrize and keep upper triangular only</span>

    <span class="c1"># Only the simplices that have sources stored in this temporary file will be considered.</span>
    <span class="c1"># This only makes sense for directed simplices</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">simplex_type</span><span class="o">==</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="s2">&quot;Sub-selection of source nodes only makes sense for directed simplices&quot;</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="kn">import</span> <span class="nn">os</span>
        <span class="n">tmp_file</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">vertices_todo</span> <span class="o">=</span> <span class="n">tmp_file</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">vertices_todo</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertices_todo</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="c1"># Count simplices</span>
    <span class="n">flagser_counts</span> <span class="o">=</span> <span class="n">_flagser_counts</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="n">max_simplices</span><span class="p">,</span> <span class="n">max_dim</span><span class="o">=</span><span class="n">max_dim</span><span class="p">,</span> <span class="n">vertices_todo</span><span class="o">=</span><span class="n">vertices_todo</span><span class="p">)</span>
    <span class="c1"># Remove temporary file</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vertices_todo</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_simplices</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flagser_counts</span><span class="p">[</span><span class="s2">&quot;max_simplex_counts&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flagser_counts</span><span class="p">[</span><span class="s2">&quot;simplex_counts&quot;</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.simplicial_rich_club_curve" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">simplicial_rich_club_curve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">maximal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse_bin_set</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Computes the simplicial rich club curve of a network.
   Where the i'th entry is the density of the subnetwork induced by the vertices that are contained in
   more than i (maximal) simplices.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d-array</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>max_simplices</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If true then vertex participation is the number of maximal simplices each vertex is contained in.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>sparse_bin_set</code></td>
          <td>
                <code>bool</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>If true then consecutive entries with same rich club coefficient are grouped into bins together,</p>
            </div>
          </td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="pandas.Series">Series</span></code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Where the i'th entry is the rich club coefficient of the network induced by all vertices which are
contained in more that i (maximal) simplices</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1553</span>
<span class="normal">1554</span>
<span class="normal">1555</span>
<span class="normal">1556</span>
<span class="normal">1557</span>
<span class="normal">1558</span>
<span class="normal">1559</span>
<span class="normal">1560</span>
<span class="normal">1561</span>
<span class="normal">1562</span>
<span class="normal">1563</span>
<span class="normal">1564</span>
<span class="normal">1565</span>
<span class="normal">1566</span>
<span class="normal">1567</span>
<span class="normal">1568</span>
<span class="normal">1569</span>
<span class="normal">1570</span>
<span class="normal">1571</span>
<span class="normal">1572</span>
<span class="normal">1573</span>
<span class="normal">1574</span>
<span class="normal">1575</span>
<span class="normal">1576</span>
<span class="normal">1577</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">simplicial_rich_club_curve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">maximal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse_bin_set</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the simplicial rich club curve of a network.</span>
<span class="sd">           Where the i&#39;th entry is the density of the subnetwork induced by the vertices that are contained in</span>
<span class="sd">           more than i (maximal) simplices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adj : 2d-array</span>
<span class="sd">            Adjacency matrix of a directed network.</span>
<span class="sd">        max_simplices : bool</span>
<span class="sd">            If true then vertex participation is the number of maximal simplices each vertex is contained in.</span>
<span class="sd">        sparse_bin_set : bool</span>
<span class="sd">            If true then consecutive entries with same rich club coefficient are grouped into bins together,</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            Where the i&#39;th entry is the rich club coefficient of the network induced by all vertices which are</span>
<span class="sd">            contained in more that i (maximal) simplices</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">pyflagsercount</span>
    <span class="kn">from</span> <span class="nn">.classic</span> <span class="kn">import</span> <span class="n">efficient_rich_club_curve</span>
    <span class="n">vertex_par</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pyflagsercount</span><span class="o">.</span><span class="n">flagser_count</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">max_simplices</span><span class="o">=</span><span class="n">maximal</span><span class="p">,</span> <span class="n">containment</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="s1">&#39;contain_counts&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">efficient_rich_club_curve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">pre_calculated_richness</span><span class="o">=</span><span class="n">vertex_par</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vertex_par</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.tcc" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">tcc</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Computes the transitive clustering coefficient of the graph induced by 
    the neighbourhood of center in matrix</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>matrix</code></td>
          <td>
                <code>2d-array</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of a directed network.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>center</code></td>
          <td>
                <code>int</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The index of the vertex to be considered, default=0</p>
            </div>
          </td>
          <td>
                <code>0</code>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>float</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>The transitive cluster coefficient of the neighbourhood of center</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1606</span>
<span class="normal">1607</span>
<span class="normal">1608</span>
<span class="normal">1609</span>
<span class="normal">1610</span>
<span class="normal">1611</span>
<span class="normal">1612</span>
<span class="normal">1613</span>
<span class="normal">1614</span>
<span class="normal">1615</span>
<span class="normal">1616</span>
<span class="normal">1617</span>
<span class="normal">1618</span>
<span class="normal">1619</span>
<span class="normal">1620</span>
<span class="normal">1621</span>
<span class="normal">1622</span>
<span class="normal">1623</span>
<span class="normal">1624</span>
<span class="normal">1625</span>
<span class="normal">1626</span>
<span class="normal">1627</span>
<span class="normal">1628</span>
<span class="normal">1629</span>
<span class="normal">1630</span>
<span class="normal">1631</span>
<span class="normal">1632</span>
<span class="normal">1633</span>
<span class="normal">1634</span>
<span class="normal">1635</span>
<span class="normal">1636</span>
<span class="normal">1637</span>
<span class="normal">1638</span>
<span class="normal">1639</span>
<span class="normal">1640</span>
<span class="normal">1641</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">tcc</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span><span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the transitive clustering coefficient of the graph induced by </span>
<span class="sd">            the neighbourhood of center in matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        matrix : 2d-array</span>
<span class="sd">            Adjacency matrix of a directed network.</span>
<span class="sd">        center : int</span>
<span class="sd">            The index of the vertex to be considered, default=0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The transitive cluster coefficient of the neighbourhood of center</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.classic</span> <span class="kn">import</span> <span class="n">reciprocal_connections</span>
    <span class="n">outdeg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">center</span><span class="p">])</span>
    <span class="n">indeg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">matrix</span><span class="p">)[</span><span class="n">center</span><span class="p">])</span>
    <span class="n">repdeg</span> <span class="o">=</span> <span class="n">reciprocal_connections</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">chief_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">totdeg</span> <span class="o">=</span> <span class="n">indeg</span><span class="o">+</span><span class="n">outdeg</span>

    <span class="c1">#If matrix is not already neighbourhood of center, then compute neighbourhood.</span>
    <span class="k">if</span> <span class="n">totdeg</span><span class="o">-</span><span class="n">repdeg</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">neighbourhood</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">chief_containment</span> <span class="o">=</span> <span class="n">node_participation</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span><span class="n">max_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chief_containment</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">chief_containment</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">totdeg</span><span class="o">*</span><span class="p">(</span><span class="n">totdeg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">indeg</span><span class="o">*</span><span class="n">outdeg</span><span class="o">+</span><span class="n">repdeg</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">numerator</span><span class="o">/</span><span class="n">denominator</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">



<h2 id="src.connalysis.network.topology.underlying_undirected_matrix" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">underlying_undirected_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Returns the symmetric matrix of undirected connections of <code>adj</code>.</p>



  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>adj</code></td>
          <td>
                <code>2d array or sparse matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Adjacency matrix of the directed network.  A non-zero entry in <code>adj[i][j]</code> implies there is an edge from vertex <code>i</code> to vertex <code>j</code>.</p>
            </div>
          </td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>



  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code>sparse boolean matrix</code>
          </td>
          <td>
            <div class="doc-md-description">
              <p>Corresponding to the symmetric underlying undirected graph</p>
            </div>
          </td>
        </tr>
    </tbody>
  </table>

          <details class="quote">
            <summary>Source code in <code>src/connalysis/network/topology.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">underlying_undirected_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the symmetric matrix of undirected connections of `adj`.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adj : 2d array or sparse matrix</span>
<span class="sd">        Adjacency matrix of the directed network.  A non-zero entry in `adj[i][j]` implies there is an edge from vertex `i` to vertex `j`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sparse boolean matrix</span>
<span class="sd">        Corresponding to the symmetric underlying undirected graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;The diagonal is non-zero and this may lead to errors!&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">adj</span><span class="o">+</span><span class="n">adj</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>



  </div>

  </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.bd41221c.min.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>